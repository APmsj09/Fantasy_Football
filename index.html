<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Football Draft Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for graphing -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .table-container {
            max-height: 500px;
            overflow-y: auto;
        }
        .roster-content {
            max-height: 400px;
            overflow-y: auto;
        }
        /* Custom scrollbar for better aesthetics */
        .table-container::-webkit-scrollbar, .roster-content::-webkit-scrollbar {
            width: 8px;
            background-color: #f1f1f1;
            border-radius: 4px;
        }
        .table-container::-webkit-scrollbar-thumb, .roster-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        .table-container::-webkit-scrollbar-thumb:hover, .roster-content::-webkit-scrollbar-thumb:hover {
            background-color: #94a3b8;
        }
        /* Individual tab styling */
        .tab {
            @apply px-4 py-2 text-sm font-medium text-gray-600 border border-gray-200 rounded-t-lg transition duration-200 cursor-pointer -mb-px; /* Added full border, rounded top, and negative margin to overlap */
        }
        .tab.active {
            @apply text-indigo-600 border-indigo-600 font-semibold bg-white; /* Active tab stands out */
        }
        .tab:not(.active) {
            @apply bg-gray-50 hover:bg-gray-100; /* Inactive tabs look clickable */
        }
        /* Ensure canvas itself is responsive within its container */
        canvas {
            width: 100% !important;
            height: auto !important;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Fantasy Football Draft Assistant</h1>
            <p class="text-lg text-gray-600 mt-2">12-Team Snake Draft Edition</p>
        </header>

        <!-- Setup Screen -->
        <div id="setup-screen" class="bg-white p-6 rounded-lg shadow-md max-w-lg mx-auto">
            <h2 class="text-2xl font-semibold mb-4 text-center">Setup Draft</h2>
            <div class="space-y-4">
                <div>
                    <label for="data-file" class="block text-sm font-medium text-gray-700 mb-1">1a. Upload Player TSV File</label>
                    <input type="file" id="data-file" accept=".tsv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100">
                </div>
                
                <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-gray-300">
                    <span class="text-xs text-gray-500 font-semibold">OR</span>
                    <hr class="flex-grow border-gray-300">
                </div>

                <div class="space-y-2">
                    <label for="url-input" class="block text-sm font-medium text-gray-700 mb-1">1b. Paste Player TSV URL</label>
                    <div class="flex space-x-2">
                        <input type="url" id="url-input" placeholder="e.g., https://example.com/data.tsv" class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <button id="load-url-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled-button" disabled>Load</button>
                    </div>
                </div>
                
                <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-gray-300">
                    <span class="text-xs text-gray-500 font-semibold">OR</span>
                    <hr class="flex-grow border-gray-300">
                </div>
                
                <button id="load-data-button" class="w-full bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">1c. Load Player Data from GitHub</button>
                
                <div class="flex space-x-2">
                    <button id="load-draft-button" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Load Existing Draft</button>
                </div>
            </div>
        </div>

        <!-- Drafting Screen -->
        <div id="drafting-screen" class="hidden">
            
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8"> 
                <!-- Left Column: Draft Status, Recommendations, Top 5 (stacked), then Draft Controls at bottom -->
                <div class="md:col-span-1 flex flex-col gap-6"> <!-- Using flex-col with gap for vertical spacing -->
                    
                    <div id="draft-status" class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="font-semibold text-lg mb-2">Draft Status</h3>
                        <div class="space-y-1 text-sm">
                            <p><strong>Round:</strong> <span id="current-round">N/A</span></p>
                            <p><strong>Pick:</strong> <span id="current-pick-number">N/A</span></p>
                            <p class="text-lg font-bold text-indigo-600"><strong>On the Clock:</strong> <span id="on-the-clock">N/A</span></p>
                        </div>
                        <div class="mt-4">
                            <h4 class="font-semibold text-md mb-2">Upcoming Picks:</h4>
                            <ul id="upcoming-picks" class="text-sm list-disc list-inside space-y-0.5"></ul>
                        </div>
                    </div>

                    <!-- Recommended Picks moved here -->
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-4 border-b pb-2">Recommended Picks</h3>
                        <div id="recommendations-container" class="space-y-4">
                            <p class="text-gray-500">Recommendations will appear here after the draft starts.</p>
                        </div>
                    </div>

                    <!-- Top 5 Available moved here -->
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-4 border-b pb-2">Top 5 Available</h3>
                        <div id="top-5-container" class="space-y-4"></div>
                    </div>

                    <!-- Draft Controls moved to the very bottom of the left column -->
                    <div class="bg-white p-6 rounded-lg shadow-md mt-auto"> <!-- mt-auto pushes it to the bottom -->
                        <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Draft Controls</h2>
                        <div class="space-y-4">
                            <button id="save-draft" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save Draft</button>
                            <button id="undo-pick-button" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mt-2">Undo Last Pick</button>
                            <button id="view-standings-button" class="w-full bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mt-2">View Projected Standings</button>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Available Players, Team Rosters (now col-span-3) -->
                <div class="md:col-span-3 space-y-8"> 
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h2 class="text-2xl font-semibold mb-4">Available Players</h2>
                        <div class="space-y-4">
                            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                                <input type="text" id="player-search" placeholder="Search Player..." class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <select id="position-filter" class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white">
                                    <option value="">All Positions</option>
                                    <option value="QB">QB</option>
                                    <option value="RB">RB</option>
                                    <option value="WR">WR</option>
                                    <option value="TE">TE</option>
                                    <option value="PK">PK</option>
                                    <option value="DST">DST</option>
                                </select>
                                <select id="sort-by" class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white">
                                    <option value="VBD" selected>VBD (Highest First)</option>
                                    <option value="2025 Projected Fantasy Points">Proj. Points (Highest First)</option>
                                    <option value="Player">Player Name (A-Z)</option>
                                    <option value="Pos">Position (A-Z)</option>
                                    <option value="Team">Team (A-Z)</option>
                                </select>
                            </div>
                        </div>
                        <div class="table-container border rounded-lg mt-4">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50 sticky top-0">
                                    <tr>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Player</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Pos</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Team</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bye</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Proj. Pts</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">VBD</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="players-body" class="bg-white divide-y divide-gray-200"></tbody>
                            </table>
                            <p id="no-available-players" class="text-center text-gray-500 p-4 hidden">No players available based on current filters.</p>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h2 class="text-2xl font-semibold mb-4">Team Rosters</h2>
                        <!-- Parent container for tabs with flex, no direct borders for individual tab styling -->
                        <div id="roster-tabs" class="flex flex-wrap gap-x-1"></div> 
                        <!-- Content container will have borders -->
                        <div id="roster-content" class="roster-content mt-4 border border-gray-200 rounded-lg"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Summary Screen -->
        <div id="summary-screen" class="hidden bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto my-8">
            <h2 class="text-3xl font-bold text-gray-900 mb-6 text-center">Projected Final Standings</h1>
            <div id="standings-list" class="space-y-3">
                <!-- Standings will be rendered here -->
            </div>
            <button id="close-summary-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mt-6">Close Summary</button>
        </div>

        <!-- Custom Message Box -->
        <div id="message-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h3 id="message-modal-title" class="text-xl font-bold text-gray-800 mb-4"></h3>
                <p id="message-modal-content" class="text-gray-700 mb-6"></p>
                <button id="message-modal-close" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        // --- STATE MANAGEMENT ---
        let players = [];
        let teamsById = {};
        let draftOrder = [];
        let currentPick = 0;
        let draftStarted = false;
        let draftHistory = [];
        let rosterCharts = {}; // To store Chart.js instances

        // --- ROSTER SETTINGS ---
        // Updated roster settings as per user's request: 1QB, 2RB, 2WR, 1TE, 2FLEX, 1K, 1DST
        const rosterSettings = {
            QB: { min: 1, max: 1 }, 
            RB: { min: 2, max: 2 }, 
            WR: { min: 2, max: 2 }, 
            TE: { min: 1, max: 1 }, 
            Flex: { min: 2, max: 2 }, 
            PK: { min: 1, max: 1 }, 
            DST: { min: 1, max: 1 }, // Changed from Def to DST
            totalStarters: 10, // 1 QB + 2 RB + 2 WR + 1 TE + 2 Flex + 1 PK + 1 DST = 10
            bench: 6, // 16 total size - 10 starters = 6
            totalSize: 16
        };

        // --- DOM ELEMENTS (Declared here, assigned in window.onload) ---
        let setupScreen;
        let draftingScreen;
        let fileInput;
        let playersBody;
        let saveButton;
        let loadDraftButton;
        let undoButton;
        let loadDataButton;
        let urlInput;
        let loadUrlButton;
        let upcomingPicksList;
        let playerSearchInput;
        let positionFilterSelect;
        let sortBySelect;
        let noAvailablePlayersMessage;
        let top5Container;
        let recommendationsContainer;
        let rosterTabsContainer;
        let rosterContentContainer;
        let currentRoundSpan; 
        let currentPickNumberSpan;
        let onTheClockSpan;
        let summaryScreen; // New summary screen element
        let standingsList; // New standings list element
        let viewStandingsButton; // New view standings button
        let closeSummaryButton; // New close summary button

        // New DOM elements for the message modal
        let messageModal;
        let messageModalTitle;
        let messageModalContent;
        let messageModalCloseButton;

        // --- Hard-coded URL for your TSV file ---
        const tsvFileUrl = 'https://raw.githubusercontent.com/APmsj09/Fantasy_Football/main/Data.tsv';

        /**
         * Generates a UUID.
         * @returns {string} A unique ID.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Function to show custom message box.
         * @param {string} title - The title of the message.
         * @param {string} message - The content of the message.
         */
        function showMessage(title, message) {
            if (messageModal && messageModalTitle && messageModalContent) {
                messageModalTitle.textContent = title;
                messageModalContent.textContent = message;
                messageModal.classList.remove('hidden');
            } else {
                console.warn("Message modal elements not fully initialized. Falling back to console log:", title, message);
                console.log(`${title}: ${message}`);
            }
        }


        /**
         * Switches the view from the setup screen to the main drafting screen.
         */
        function showDraftingScreen() {
            setupScreen.classList.add('hidden');
            draftingScreen.classList.remove('hidden');
        }

        /**
         * Initializes the draft with default teams or loaded team names.
         * @param {Array<string>} [initialTeamNames] - Optional array of team names to use.
         */
        function initializeDraftSetup(initialTeamNames = []) {
            teamsById = {};
            draftOrder = [];
            currentPick = 0;
            draftHistory = [];
            draftStarted = true;

            let teamsToCreate = initialTeamNames.length > 0 ? initialTeamNames : Array.from({ length: 12 }, (_, i) => `Team ${i + 1}`);
            
            // Create teams with unique IDs
            let teamIds = [];
            teamsToCreate.forEach(name => {
                const id = generateUUID();
                // Initialize positions with 0 count
                const initialPositions = {};
                Object.keys(rosterSettings).forEach(pos => {
                    if (pos !== 'totalStarters' && pos !== 'bench' && pos !== 'totalSize') {
                        initialPositions[pos] = 0;
                    }
                });
                teamsById[id] = { id: id, name: name, roster: [], positions: initialPositions };
                teamIds.push(id);
            });

            // Populate draft order with team IDs
            for (let i = 0; i < rosterSettings.totalSize; i++) {
                const roundOrder = [...teamIds];
                if ((i + 1) % 2 === 0) { // Snake draft logic
                    roundOrder.reverse();
                }
                draftOrder.push(...roundOrder);
            }

            showDraftingScreen();
            updateDraftStatus();
            renderRosters();
            applyFiltersAndSort();
        }


        /**
         * Parses TSV text into an array of player objects, including weekly projections.
         * @param {string} text - The TSV content.
         * @returns {Array<Object>} Array of player objects.
         */
        function parseTSV(text) {
            const rows = text.split(/\r?\n/).filter(row => row.trim() !== '');
            if (rows.length < 2) {
                showMessage('Data Error', 'Data file must have a header and at least one player row.');
                return [];
            }
            const rawHeaders = rows[0].split('\t');
            const headers = rawHeaders.map(h => h.trim());
            console.log("TSV Headers found:", headers);

            // Find index of crucial columns
            const playerIndex = headers.indexOf('Player');
            const teamIndex = headers.indexOf('Team'); 
            const posIndex = headers.indexOf('Pos');   
            const projectedPointsIndex = headers.indexOf('2025 Projected Fantasy Points');
            const vbdIndex = headers.indexOf('VBD');
            const byeWeekIndex = headers.indexOf('Bye Week');

            if (playerIndex === -1 || teamIndex === -1 || posIndex === -1) {
                showMessage('Data Error', 'Required columns (Player, Team, Pos) not found in the TSV file.');
                return [];
            }

            const parsedPlayers = [];
            for (let i = 1; i < rows.length; i++) {
                const values = rows[i].split('\t').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn(`Skipping row ${i + 1} due to header/value mismatch. Headers: ${headers.length}, Values: ${values.length}. Row: ${rows[i]}`);
                    continue; 
                }
                
                let player = {};
                player.Player = values[playerIndex];
                
                // Assign Team from the 'Team' column, and Pos from the 'Pos' column
                player.Team = values[teamIndex]; 
                player.Pos = values[posIndex]; 
                
                // Standardize 'K' to 'PK' and 'DEF' to 'DST'
                if (player.Pos === 'K') {
                    player.Pos = 'PK';
                } else if (player.Pos === 'DEF') {
                    player.Pos = 'DST'; 
                }

                player['2025 Projected Fantasy Points'] = parseFloat(values[projectedPointsIndex]) || 0;
                player.VBD = (vbdIndex !== -1) ? parseFloat(values[vbdIndex]) || 0 : player['2025 Projected Fantasy Points'];
                player['Bye Week'] = values[byeWeekIndex];

                // Extract Weekly Projections
                for (let week = 1; week <= 18; week++) { // Assuming up to Week 18 projections
                    const weekHeader = `Week ${week}`; 
                    const weekIndex = headers.indexOf(weekHeader);
                    if (weekIndex !== -1) {
                        let rawValue = values[weekIndex].trim();
                        let parsedValue = parseFloat(rawValue);
                        if (isNaN(parsedValue)) {
                            parsedValue = 0; 
                        }
                        player[weekHeader] = parsedValue;
                    } else {
                        player[weekHeader] = 0; 
                    }
                }

                parsedPlayers.push(player);
            }
            return parsedPlayers;
        }

        /**
         * Fetches and loads player data from a given URL.
         * @param {string} url - The URL of the TSV file.
         */
        function loadPlayersFromUrl(url) {
            const isGitHub = url.includes('github.com');
            let buttonToUpdate = isGitHub ? loadDataButton : loadUrlButton;
            
            buttonToUpdate.textContent = "Loading...";
            buttonToUpdate.disabled = true;

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok. Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    players = parseTSV(text);
                    if (players.length > 0) {
                        showMessage('Success', 'Player data loaded successfully!');
                        buttonToUpdate.textContent = "Data Loaded!";
                        buttonToUpdate.classList.add('bg-green-500', 'hover:bg-green-600');
                        console.log("Players loaded successfully. Number of players:", players.length);
                        initializeDraftSetup(); // Automatically start draft after data loads
                    } else {
                         throw new Error('No player data found in the file.');
                    }
                })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
                    showMessage('Error', `Failed to load data from URL: ${error.message}`);
                    buttonToUpdate.textContent = "Failed to Load";
                    buttonToUpdate.classList.remove('bg-green-500', 'hover:bg-green-600');
                    buttonToUpdate.classList.add('bg-red-500', 'hover:bg-red-600');
                })
                .finally(() => {
                    buttonToUpdate.disabled = false;
                });
        }

        /**
         * Handles local data file upload and parsing.
         */
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                players = parseTSV(text);
                if (players.length > 0) {
                    showMessage('Success', 'Player data uploaded successfully from your device!');
                    console.log("Players loaded successfully from file. Number of players:", players.length);
                    initializeDraftSetup(); // Automatically start draft after data loads
                } else {
                    showMessage('Error', 'Failed to parse player data from the file. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }
        
        /**
         * Updates the UI with the current draft status and upcoming picks.
         */
        function updateDraftStatus() {
            if (!draftStarted || currentPick >= draftOrder.length) {
                onTheClockSpan.textContent = "Draft Complete!";
                currentRoundSpan.textContent = (rosterSettings.totalSize).toString();
                currentPickNumberSpan.textContent = draftOrder.length.toString();
                upcomingPicksList.innerHTML = '<li class="text-gray-500">Draft has concluded.</li>';
                
                // Automatically show summary when draft completes
                if (draftStarted && currentPick >= draftOrder.length) { 
                    renderSummaryPage();
                }
                return;
            }

            const round = Math.floor(currentPick / 12) + 1;
            const pickInRound = (currentPick % 12) + 1;
            const overallPick = currentPick + 1;
            const currentTeamId = draftOrder[currentPick];
            const currentTeamName = teamsById[currentTeamId].name;

            currentRoundSpan.textContent = round;
            currentPickNumberSpan.textContent = `${overallPick} (${pickInRound})`;
            onTheClockSpan.textContent = currentTeamName;

            upcomingPicksList.innerHTML = '';
            const numberOfFuturePicks = 5;
            for (let i = 1; i <= numberOfFuturePicks; i++) {
                const futurePickIndex = currentPick + i;
                if (futurePickIndex < draftOrder.length) {
                    const futureRound = Math.floor(futurePickIndex / 12) + 1;
                    const futurePickInRound = (futurePickIndex % 12) + 1;
                    const futureTeamId = draftOrder[futurePickIndex];
                    const futureTeamName = teamsById[futureTeamId].name;
                    upcomingPicksList.innerHTML += `<li>Pick ${futurePickIndex + 1} (R${futureRound}, P${futurePickInRound}): ${futureTeamName}</li>`;
                } else {
                    break;
                }
            }
            if (upcomingPicksList.innerHTML === '') {
                upcomingPicksList.innerHTML = '<li class="text-gray-500">No more future picks.</li>';
            }

            if (draftStarted) {
                renderRecommendations();
            }
        }

        /**
         * Calculates the projected points for each starting roster slot for a given team's roster for a specific week.
         * This determines which players would be in the "optimal" starting lineup for that week.
         *
         * @param {Array<Object>} teamRoster - The roster of players for a specific team. Each player object should have 'Pos' and 'Week X' properties.
         * @param {string} weekKey - The key for the week's projected points (e.g., 'Week 1').
         * @returns {Object} An object containing:
         * - totalPoints: The sum of projected points for the optimal lineup.
         * - lineupSlots: An object mapping each roster slot (e.g., 'QB', 'RB1', 'Flex1') to the player filling it and their points.
         */
        function calculateRosterSpotsPoints(teamRoster, weekKey) {
            const activePlayers = teamRoster.filter(p => typeof p[weekKey] === 'number' && p[weekKey] > 0);
            
            // Group players by position
            const playersByPos = {
                QB: [], RB: [], WR: [], TE: [], PK: [], DST: [] 
            };
            activePlayers.forEach(player => {
                // Ensure player.Pos is valid before adding
                if (playersByPos[player.Pos]) {
                    playersByPos[player.Pos].push(player);
                } else {
                    console.warn(`Unknown position '${player.Pos}' for player ${player.Player} in ${weekKey}.`);
                }
            });

            // Sort players within each position by their projected points for the given week (descending)
            Object.keys(playersByPos).forEach(pos => {
                playersByPos[pos].sort((a, b) => (b[weekKey] || 0) - (a[weekKey] || 0));
            });

            const lineupSlots = {};
            const usedPlayers = new Set(); 
            let totalPoints = 0;

            // Helper to fill a fixed number of primary slots
            const fillPrimarySlots = (pos, count, slotPrefix) => {
                for (let i = 0; i < count; i++) {
                    const player = playersByPos[pos].find(p => !usedPlayers.has(p.Player));
                    if (player) {
                        const slotName = `${slotPrefix}${count > 1 ? i + 1 : ''}`; 
                        lineupSlots[slotName] = { player: player, points: player[weekKey] };
                        usedPlayers.add(player.Player);
                        totalPoints += player[weekKey];
                    } else {
                        const slotName = `${slotPrefix}${count > 1 ? i + 1 : ''}`;
                        lineupSlots[slotName] = { player: null, points: 0 };
                    }
                }
            };

            // Fill dedicated primary positions (QB, PK, DST, and min for RB, WR, TE)
            fillPrimarySlots('QB', rosterSettings.QB.min, 'QB');
            fillPrimarySlots('PK', rosterSettings.PK.min, 'PK');
            fillPrimarySlots('DST', rosterSettings.DST.min, 'DST'); 
            fillPrimarySlots('RB', rosterSettings.RB.min, 'RB');
            fillPrimarySlots('WR', rosterSettings.WR.min, 'WR');
            fillPrimarySlots('TE', rosterSettings.TE.min, 'TE');

            // Collect remaining Flex-eligible players (RB, WR, TE)
            let flexCandidates = [];
            ['RB', 'WR', 'TE'].forEach(pos => {
                flexCandidates.push(...playersByPos[pos].filter(p => !usedPlayers.has(p.Player)));
            });
            flexCandidates.sort((a, b) => (b[weekKey] || 0) - (a[weekKey] || 0));

            // Fill Flex spots
            for (let i = 0; i < rosterSettings.Flex.max; i++) {
                const player = flexCandidates.find(p => !usedPlayers.has(p.Player));
                if (player) {
                    lineupSlots[`Flex${i + 1}`] = { player: player, points: player[weekKey] };
                    usedPlayers.add(player.Player);
                    totalPoints += player[weekKey];
                } else {
                    lineupSlots[`Flex${i + 1}`] = { player: null, points: 0 };
                }
            }
            
            return { totalPoints, lineupSlots };
        }


        /**
         * Generates and displays a list of recommended players for the team on the clock,
         * combining VBD and projected weekly point impact (PPW).
         */
        function renderRecommendations() {
            recommendationsContainer.innerHTML = '';
            const currentTeamId = draftOrder[currentPick];
            if (!currentTeamId) { 
                recommendationsContainer.innerHTML = `<p class="text-gray-500">Draft is complete.</p>`;
                return;
            }
            const currentTeamName = teamsById[currentTeamId].name;
            const teamRoster = teamsById[currentTeamId].roster;

            const totalRounds = rosterSettings.totalSize;
            const currentRound = Math.floor(currentPick / 12) + 1;

            // Dynamic weights for VBD and Impact based on current round
            const vbdStartWeight = 0.7;
            const impactStartWeight = 0.3;
            const vbdEndWeight = 0.1;
            const impactEndWeight = 0.9;

            let vbdWeight = vbdStartWeight;
            let impactWeight = impactStartWeight;

            if (totalRounds > 1) { // Avoid division by zero if only one round
                const roundProgress = (currentRound - 1) / (totalRounds - 1);
                vbdWeight = vbdStartWeight - roundProgress * (vbdStartWeight - vbdEndWeight);
                impactWeight = impactStartWeight + roundProgress * (impactEndWeight - impactStartWeight);
            }
            vbdWeight = Math.max(0, Math.min(1, vbdWeight));
            impactWeight = 1 - vbdWeight;


            const WEEKS_TO_AVERAGE = 13; 

            const evaluatedPlayers = [];

            players.forEach(availablePlayer => { 
                let totalWeeklyImpact = 0;

                for (let week = 1; week <= WEEKS_TO_AVERAGE; week++) {
                    const weekKey = `Week ${week}`;
                    const hypotheticalRoster = [...teamRoster, availablePlayer];

                    const hypotheticalResults = calculateRosterSpotsPoints(hypotheticalRoster, weekKey);
                    const hypotheticalTotalPoints = hypotheticalResults.totalPoints;

                    const baselineResultsForWeek = calculateRosterSpotsPoints(teamRoster, weekKey);
                    const baselineTotalPointsForWeek = baselineResultsForWeek.totalPoints;

                    totalWeeklyImpact += (hypotheticalTotalPoints - baselineTotalPointsForWeek);
                }

                const averageWeeklyImpact = totalWeeklyImpact / WEEKS_TO_AVERAGE;

                const recommendationScore = (availablePlayer.VBD * vbdWeight) + (averageWeeklyImpact * impactWeight);

                let reason = `VBD: ${availablePlayer.VBD.toFixed(2)}.`;
                if (averageWeeklyImpact > 0) {
                    reason += ` Expected +${averageWeeklyImpact.toFixed(1)} avg. weekly point upgrade (PPW).`;
                } else if (averageWeeklyImpact === 0) {
                    reason += ` No immediate average weekly point upgrade (PPW).`;
                } else { 
                    reason += ` Expected ${averageWeeklyImpact.toFixed(1)} avg. weekly point change (PPW).`;
                }

                evaluatedPlayers.push({
                    player: availablePlayer,
                    recommendationScore: recommendationScore,
                    weeklyImpact: averageWeeklyImpact,
                    reason: reason
                });
            });

            evaluatedPlayers.sort((a, b) => b.recommendationScore - a.recommendationScore);

            const top5FinalRecommendations = evaluatedPlayers.slice(0, 5);

            if (top5FinalRecommendations.length > 0) {
                top5FinalRecommendations.forEach(rec => {
                    const player = rec.player;
                    const recCard = document.createElement('div');
                    recCard.className = 'p-3 bg-gray-50 rounded-lg border flex items-center justify-between hover:bg-gray-100 cursor-pointer';
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.innerHTML = `
                        <h4 class="font-bold text-md text-indigo-600">${player.Player}</h4>
                        <p class="text-sm text-gray-600">${player.Pos} - ${player.Team} | VBD: ${player.VBD.toFixed(2)}</p>
                        <p class="text-xs text-gray-500 mt-1">${rec.reason}</p>
                    `;

                    const draftButton = document.createElement('button');
                    draftButton.className = 'bg-green-600 text-white text-xs px-3 py-1 rounded hover:bg-green-700 draft-button flex items-center space-x-1'; 
                    draftButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg><span>Select</span>`; 
                    draftButton.setAttribute('data-player-id', player.Player); 

                    // Attach the button to the card
                    recCard.appendChild(infoDiv);
                    recCard.appendChild(draftButton);
                    
                    // Append the card to the container
                    recommendationsContainer.appendChild(recCard);
                });
                recommendationsContainer.innerHTML += `<p class="text-xs text-gray-500 mt-4 text-center">Recommendation weights: VBD ${vbdWeight.toFixed(2)}, Impact ${impactWeight.toFixed(2)}</p>`;
            } else {
                recommendationsContainer.innerHTML = `<p class="text-gray-500">No specific recommendations at this time.</p>`;
            }
        }

        /**
         * Applies current filters and sort order to the available players
         * and then renders the main players table.
         */
        function applyFiltersAndSort() {
            let filteredPlayers = [...players];

            const searchTerm = playerSearchInput.value.toLowerCase();
            if (searchTerm) {
                filteredPlayers = filteredPlayers.filter(player =>
                    player.Player.toLowerCase().includes(searchTerm) ||
                    player.Team.toLowerCase().includes(searchTerm)
                );
            }

            const selectedPosition = positionFilterSelect.value;
            if (selectedPosition) {
                filteredPlayers = filteredPlayers.filter(player => player.Pos === selectedPosition);
            }

            const sortBy = sortBySelect.value;
            filteredPlayers.sort((a, b) => {
                if (sortBy === 'Player' || sortBy === 'Pos' || sortBy === 'Team' || sortBy === 'Bye Week') {
                    return a[sortBy].localeCompare(b[sortBy]);
                } else if (sortBy === '2025 Projected Fantasy Points' || sortBy === 'VBD') {
                    return b[sortBy] - a[sortBy];
                }
                return 0;
            });

            renderPlayers(filteredPlayers);
            renderTop5(); 
        }

        /**
         * Renders the list of available players based on the provided array.
         */
        function renderPlayers(playersToRender) {
            playersBody.innerHTML = '';
            if (playersToRender.length === 0) {
                noAvailablePlayersMessage.classList.remove('hidden');
            } else {
                noAvailablePlayersMessage.classList.add('hidden');
                playersToRender.forEach((player) => {
                    const tr = document.createElement('tr');
                    tr.className = 'hover:bg-gray-100 cursor-pointer';
                    tr.ondblclick = () => draftPlayer(player);
                    
                    tr.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${player.Player}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Pos}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Team}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['Bye Week']}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['2025 Projected Fantasy Points']}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.VBD !== undefined ? player.VBD.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                            <button class="bg-green-600 text-white text-xs px-3 py-1 rounded hover:bg-green-700 draft-button flex items-center space-x-1">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg><span>Select</span>
                            </button>
                        </td>
                    `;
                    const draftButton = tr.querySelector('.draft-button');
                    draftButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        draftPlayer(player);
                    });

                    playersBody.appendChild(tr);
                });
            }
        }

        /**
         * Handles editing a team's name directly from the roster tab.
         * @param {HTMLInputElement} inputElement - The input field being edited.
         * @param {string} teamId - The unique ID of the team being edited.
         */
        function editTeamName(inputElement, teamId) {
            const newName = inputElement.value.trim();
            if (newName && newName !== teamsById[teamId].name) {
                // Check for duplicate names (optional, but good practice)
                const isDuplicate = Object.values(teamsById).some(team => team.id !== teamId && team.name === newName);
                if (isDuplicate) {
                    showMessage('Error', 'Team name must be unique!');
                    inputElement.value = teamsById[teamId].name; // Revert to old name
                    return;
                }
                teamsById[teamId].name = newName;
                console.log(`Team ${teamId} name updated to: ${newName}`);
                renderRosters(); // Re-render tabs to show updated name
                updateDraftStatus(); // Update "On the Clock" if needed
            } else {
                inputElement.value = teamsById[teamId].name; // Revert if empty or no change
            }
        }

        /**
         * Renders the tabbed roster UI.
         */
        function renderRosters() {
            rosterTabsContainer.innerHTML = '';
            rosterContentContainer.innerHTML = '';
            
            // Sort teams by their current display names
            const sortedTeamIds = Object.values(teamsById)
                                        .sort((a, b) => a.name.localeCompare(b.name))
                                        .map(team => team.id);
            
            let activeTabId = sortedTeamIds[0];
            const savedActiveTab = localStorage.getItem('activeRosterTab');
            if (savedActiveTab && sortedTeamIds.includes(savedActiveTab)) {
                activeTabId = savedActiveTab;
            }

            sortedTeamIds.forEach(teamId => {
                const team = teamsById[teamId];
                const isActive = teamId === activeTabId;
                const tab = document.createElement('button');
                // Added gap-x-1 to the parent roster-tabs div, so removed -mb-px from here
                tab.className = `tab ${isActive ? 'active' : ''}`;
                tab.textContent = team.name; // Display team's current name
                tab.onclick = () => switchRosterTab(team.id);
                rosterTabsContainer.appendChild(tab);
            });

            renderRosterContent(activeTabId);
        }

        /**
         * Renders the content for a specific team roster tab.
         * @param {string} teamId - The ID of the team to display.
         */
        function renderRosterContent(teamId) {
            rosterContentContainer.innerHTML = '';
            const teamData = teamsById[teamId];
            if (!teamData) {
                rosterContentContainer.innerHTML = '<p class="text-sm text-gray-500">Roster not found.</p>';
                return;
            }
            localStorage.setItem('activeRosterTab', teamId);

            const allRosterPositions = Object.keys(rosterSettings).filter(p => !['totalStarters', 'bench', 'totalSize'].includes(p));
            const posColors = {
                'QB': 'bg-blue-100',
                'RB': 'bg-green-100',
                'WR': 'bg-yellow-100',
                'TE': 'bg-red-100',
                'Flex': 'bg-purple-100', 
                'PK': 'bg-gray-200',
                'DST': 'bg-indigo-100', 
                'Bench': 'bg-gray-100' // Added color for Bench players
            };
            const chartColors = { // Specific colors for chart lines
                'QB': 'rgb(54, 162, 235)', // Blue
                'RB': 'rgb(75, 192, 192)', // Green-ish
                'WR': 'rgb(255, 205, 86)', // Yellow
                'TE': 'rgb(255, 99, 132)', // Red
                'Flex': 'rgb(153, 102, 255)', // Purple
                'PK': 'rgb(201, 203, 207)', // Grey
                'DST': 'rgb(255, 159, 64)', 
                'Total': 'rgb(0, 0, 0)' // Black for total
            };


            const posSummary = allRosterPositions
                .map(pos => `${pos}: ${teamData.positions[pos] || 0}`)
                .join(', ');

            const playersHtml = teamData.roster.map(p => `
                <li class="flex justify-between items-center text-sm border-b border-gray-200 last:border-b-0 py-1 px-2 ${posColors[p.slottedPos] || 'bg-gray-50'} rounded">
                    <span class="font-medium">${p.Player}</span>
                    <span class="text-gray-600">${p.Pos} - ${p.Team} (${p.slottedPos})</span>
                </li>
            `).join('');

            // Calculate weekly points for optimal lineup for Weeks 1-13
            const weeklyPointsForChart = {};
            const chartLabels = [];
            let weeklyBreakdownHtml = ''; // New variable to store the weekly breakdown list
            for (let week = 1; week <= 13; week++) { // Iterate weeks 1-13 for chart
                chartLabels.push(`Week ${week}`);
                const weekKey = `Week ${week}`;
                
                // Call the helper function to get optimal lineup points for this week
                const { totalPoints, lineupSlots } = calculateRosterSpotsPoints(teamData.roster, weekKey);
                
                weeklyPointsForChart[weekKey] = {
                    total: totalPoints,
                    positions: {}
                };

                allRosterPositions.forEach(pos => {
                    weeklyPointsForChart[weekKey].positions[pos] = 0;
                });

                Object.values(lineupSlots).forEach(slot => {
                    if (slot.player) {
                        const playerPos = slot.player.Pos; // Use player's actual position
                        if (allRosterPositions.includes(playerPos)) {
                            weeklyPointsForChart[weekKey].positions[playerPos] = (weeklyPointsForChart[weekKey].positions[playerPos] || 0) + slot.points;
                        }
                    }
                });
                // Add to the weekly breakdown HTML
                weeklyBreakdownHtml += `<li class="flex justify-between items-center text-sm py-1 px-2 border-b border-gray-200 last:border-b-0">
                                            <span class="font-medium">${weekKey}:</span>
                                            <span class="text-gray-700">${totalPoints.toFixed(2)} pts</span>
                                        </li>`;
            }

            // Prepare Chart.js datasets
            const chartDatasets = [];
            const positionsInChart = allRosterPositions.filter(pos => pos !== 'Bench'); // Don't chart bench as a line

            positionsInChart.forEach(pos => {
                const data = chartLabels.map(weekKey => weeklyPointsForChart[weekKey].positions[pos]);
                if (data.some(val => val > 0)) { // Only add dataset if there are actual points for the position
                    chartDatasets.push({
                        label: pos,
                        data: data,
                        borderColor: chartColors[pos],
                        backgroundColor: chartColors[pos],
                        fill: false,
                        tension: 0.1,
                        pointRadius: 2, 
                        pointHoverRadius: 5 
                    });
                }
            });

            // Add Total Team Points dataset
            const totalData = chartLabels.map(weekKey => weeklyPointsForChart[weekKey].total);
            if (totalData.some(val => val > 0)) { // Only add if there are total points
                chartDatasets.push({
                    label: 'Total Team Points',
                    data: totalData,
                    borderColor: chartColors.Total,
                    backgroundColor: chartColors.Total,
                    borderWidth: 3,
                    pointRadius: 3, 
                    pointBackgroundColor: chartColors.Total,
                    fill: false,
                    tension: 0.1,
                    pointHoverRadius: 6 
                });
            }

            rosterContentContainer.innerHTML = `
                <div class="bg-gray-50 p-4 rounded-lg border shadow-md">
                    <h3 class="font-semibold text-lg mb-2 flex justify-between items-center">
                        <input type="text" value="${teamData.name}" class="bg-transparent font-semibold text-lg border-b border-gray-300 focus:outline-none focus:border-indigo-500 rounded-sm px-1 py-0.5 hover:bg-gray-100 transition duration-150" onblur="editTeamName(this, '${teamId}')">
                        <span class="text-sm text-gray-500">
                            <span class="text-blue-600 font-bold">${teamData.roster.length}</span>/${rosterSettings.totalSize} players
                        </span>
                    </h3>
                    <div class="w-full bg-gray-200 rounded-full h-2 mb-4">
                        <div class="bg-blue-600 h-2 rounded-full" style="width: ${(teamData.roster.length / rosterSettings.totalSize) * 100}%;"></div>
                    </div>
                    <p class="text-xs text-gray-600 mb-2">${posSummary}</p>
                    <ul class="space-y-1 mb-4">
                        ${playersHtml || '<li class="text-sm text-gray-500">Roster is empty.</li>'}
                    </ul>
                    
                    <div class="mt-4 p-3 bg-white rounded-lg border max-h-80"> 
                        <h4 class="font-semibold text-md mb-2">Weekly Projected Points (Weeks 1-13):</h4>
                        <canvas id="rosterChart-${teamId}"></canvas>
                    </div>

                    <div class="mt-4 p-3 bg-white rounded-lg border">
                        <h4 class="font-semibold text-md mb-2">Weekly Projected Points Breakdown:</h4>
                        <ul class="space-y-1 max-h-40 overflow-y-auto">
                            ${weeklyBreakdownHtml}
                        </ul>
                    </div>
                </div>
            `;

            // Destroy previous chart instance if it exists
            if (rosterCharts[teamId]) {
                rosterCharts[teamId].destroy();
            }

            // Render the new chart
            const ctx = document.getElementById(`rosterChart-${teamId}`).getContext('2d');
            rosterCharts[teamId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    animation: false, 
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Projected Points'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Week'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }
        
        /**
         * Switches the active roster tab.
         * @param {string} teamId - The ID of the team to switch to.
         */
        function switchRosterTab(teamId) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const newActiveTab = document.querySelector(`.tab[onclick="switchRosterTab('${teamId}')"]`);
            if (newActiveTab) {
                newActiveTab.classList.add('active');
            }
            renderRosterContent(teamId);
        }

        /**
         * Renders the top 5 available players for key positions.
         */
        function renderTop5() {
            top5Container.innerHTML = '';
            console.log("renderTop5 called. Current players array length:", players.length); 
            const positions = ['QB', 'RB', 'WR', 'TE']; 

            if (players.length === 0) {
                 top5Container.innerHTML = `<p class="text-gray-500 text-center">No players available.</p>`;
                 console.log("No players available to render in Top 5.");
                 return;
            }

            positions.forEach(pos => {
                const topPlayers = players.filter(p => p.Pos === pos)
                    .sort((a, b) => b.VBD - a.VBD)
                    .slice(0, 5);

                console.log(`Top players for ${pos}:`, topPlayers.map(p => `${p.Player} (VBD: ${p.VBD.toFixed(2)})`)); 

                const listItemsHtml = topPlayers.map(p => `
                    <li class="flex justify-between items-center text-sm">
                        <span class="font-medium">${p.Player}</span>
                        <span class="text-gray-600">${p.Team} - ${p.VBD.toFixed(2)} VBD</span>
                    </li>
                `).join('');

                const posSection = document.createElement('div');
                posSection.className = 'p-3 bg-gray-50 rounded-lg';
                posSection.innerHTML = `
                    <h4 class="font-bold text-md mb-2 text-indigo-600">${pos}</h4>
                    <ul class="space-y-1">
                        ${listItemsHtml || '<li class="text-sm text-gray-500">No players available.</li>'}
                    </ul>
                `;
                top5Container.appendChild(posSection);
            });
            console.log("renderTop5 finished.");
        }

        /**
         * Handles drafting a player, updating team rosters, and advancing the draft.
         */
        function draftPlayer(playerToDraft) {
            console.log('TRACE: draftPlayer START for player:', playerToDraft.Player); // TRACE START
            console.log('TRACE: currentPick:', currentPick, 'draftOrder.length:', draftOrder.length);
            console.log('TRACE: draftStarted:', draftStarted);
            console.log('TRACE: Player to draft object:', playerToDraft);

            try {
                if (!draftStarted) {
                    console.log('DEBUG: Condition met: !draftStarted is true. Showing "Draft Not Started" message.');
                    showMessage('Draft Not Started', 'Please load data to start the draft.');
                    console.log('TRACE: draftPlayer END (Draft Not Started)'); // TRACE END
                    return;
                }
                if (currentPick >= draftOrder.length) {
                    console.log('DEBUG: Condition met: currentPick >= draftOrder.length is true. Showing "Draft Complete" message.');
                    showMessage('Draft Complete', 'The draft is complete! No more picks available.');
                    console.log('TRACE: draftPlayer END (Draft Complete)'); // TRACE END
                    return;
                }

                const teamId = draftOrder[currentPick];
                const teamData = teamsById[teamId];
                const position = playerToDraft.Pos; 
                let slottedPosition = position; 

                console.log('TRACE: Current Team:', teamData.name, 'Position:', position); // Team and player pos
                console.log('TRACE: Roster settings for position:', rosterSettings[position]); // Check settings

                // Defensive check for invalid position
                if (!rosterSettings[position]) {
                    console.log('DEBUG: Condition met: !rosterSettings[position] is true. Showing "Invalid Player Position" message.');
                    console.error(`ERROR: Invalid or unexpected position '${position}' found for player ${playerToDraft.Player}.`);
                    showMessage('Invalid Player Position', `Cannot draft player: Invalid position '${position}'. Please check player data.`);
                    console.log('TRACE: draftPlayer END (Invalid Position)'); // TRACE END
                    return;
                }

                let draftedSuccessfully = false;

                // Check if overall roster is full
                if (teamData.roster.length >= rosterSettings.totalSize) {
                    console.log(`DEBUG: Condition met: Roster is full. Showing "Roster Full" message. Roster size: ${teamData.roster.length}/${rosterSettings.totalSize}`);
                    showMessage('Roster Full', `${teamData.name}'s roster is full. Total roster size: ${teamData.roster.length}/${rosterSettings.totalSize}.`);
                    console.log('TRACE: draftPlayer END (Roster Full)'); // TRACE END
                    return;
                }

                console.log(`TRACE: Attempting to draft ${playerToDraft.Player} (${playerToDraft.Pos}) for ${teamData.name}. Current roster size: ${teamData.roster.length}`);

                const currentRound = Math.floor(currentPick / 12) + 1;
                console.log('TRACE: Current Round:', currentRound);

                // --- Round 16 and later: Enforce filling minimum starting spots first ---
                if (currentRound >= 16) {
                    console.log('TRACE: In Round 16+ logic.');
                    // Check if player's primary position is a critical *unfilled minimum*
                    if (rosterSettings[position] && (teamData.positions[position] || 0) < rosterSettings[position].min) {
                        teamData.positions[position]++;
                        slottedPosition = position;
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into primary starting ${position} (enforcing min) for ${teamData.name} in Round ${currentRound}.`);
                        draftedSuccessfully = true;
                    } 
                    // If not a critical min, but it's a Flex-eligible position and a Flex spot is open, or a primary non-flex up to max.
                    // This part ensures any remaining open starter spots are filled if possible, including Flex.
                    else if (['RB', 'WR', 'TE'].includes(position) && (teamData.positions['Flex'] || 0) < rosterSettings.Flex.max) {
                        teamData.positions['Flex']++;
                        slottedPosition = 'Flex';
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into Flex for ${teamData.name} in Round ${currentRound}.`);
                        draftedSuccessfully = true;
                    }
                    else if (rosterSettings[position] && (teamData.positions[position] || 0) < rosterSettings[position].max) {
                        teamData.positions[position]++;
                        slottedPosition = position;
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into additional primary ${position} (filling max) for ${teamData.name} in Round ${currentRound}.`);
                        draftedSuccessfully = true;
                    }
                    // If no starting spot (primary or flex) available, go to bench
                    else if (teamData.roster.length < rosterSettings.totalSize) { // Ensure there's still overall roster space for bench
                        slottedPosition = 'Bench';
                        console.log(`DEBUG: ${playerToDraft.Player} drafted to Bench for ${teamData.name} in Round ${currentRound}.`);
                        draftedSuccessfully = true;
                    }
                    console.log('TRACE: After Round 16+ slotting attempts. draftedSuccessfully:', draftedSuccessfully);
                }
                // --- Before Round 16: Use flexible slotting logic ---
                else {
                    console.log('TRACE: In Before Round 16 logic.');
                    // 1. Prioritize filling primary slots for positions that don't typically go into Flex (QB, PK, DST, TE)
                    // If there's space up to their max limit, put them there.
                    if (['QB', 'PK', 'DST', 'TE'].includes(position) && (teamData.positions[position] || 0) < rosterSettings[position].max) {
                        teamData.positions[position]++;
                        slottedPosition = position;
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into primary ${position} for ${teamData.name}.`);
                        draftedSuccessfully = true;
                    } 
                    // 2. For RB/WR, try to fill primary spots up to their minimum first.
                    else if (['RB', 'WR'].includes(position) && (teamData.positions[position] || 0) < rosterSettings[position].min) {
                        teamData.positions[position]++;
                        slottedPosition = position;
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into primary ${position} (filling min) for ${teamData.name}.`);
                        draftedSuccessfully = true;
                    }
                    // 3. For RB/WR/TE, if primary minimums for RB/WR are met OR if it's a TE (and not slotted above),
                    //    try to fill a Flex spot IF available.
                    else if (['RB', 'WR', 'TE'].includes(position) && (teamData.positions['Flex'] || 0) < rosterSettings.Flex.max) {
                        teamData.positions['Flex']++;
                        slottedPosition = 'Flex';
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into Flex for ${teamData.name}.`);
                        draftedSuccessfully = true;
                    }
                    // 4. For RB/WR, if primary minimums are met and Flex is full, but there's still space up to primary max.
                    else if (['RB', 'WR'].includes(position) && (teamData.positions[position] || 0) < rosterSettings[position].max) {
                        teamData.positions[position]++;
                        slottedPosition = position;
                        console.log(`DEBUG: ${playerToDraft.Player} drafted into additional primary ${position} (filling max) for ${teamData.name}.`);
                        draftedSuccessfully = true;
                    }
                    // 5. Finally, if no other starting (primary or Flex) spot is available, put on Bench.
                    else if (teamData.roster.length < rosterSettings.totalSize) { // Ensure there's still overall roster space for bench
                        slottedPosition = 'Bench';
                        console.log(`DEBUG: ${playerToDraft.Player} drafted to Bench for ${teamData.name}.`);
                        draftedSuccessfully = true;
                    }
                    console.log('TRACE: After Before Round 16 slotting attempts. draftedSuccessfully:', draftedSuccessfully);
                }
                
                // If for some reason the player couldn't be slotted, this is a safeguard.
                if (!draftedSuccessfully) {
                    console.error('DEBUG ERROR: Player could not be slotted into any position. This indicates an issue with slotting logic, or all roster/bench spots are genuinely full or blocked by roster rules.');
                    showMessage('Drafting Error: Roster Rules', `Could not find an appropriate spot for ${playerToDraft.Player} on ${teamData.name}'s roster. This could mean all starter and bench spots are full, or there's a specific roster rule preventing this pick in Round ${currentRound}. Current roster size: ${teamData.roster.length}/${rosterSettings.totalSize}`);
                    console.log('TRACE: draftPlayer END (Not Drafted - Roster Rules)'); // TRACE END
                    return;
                }

                // --- If player was successfully slotted, proceed with draft actions ---
                draftHistory.push({
                    pickIndex: currentPick,
                    player: { ...playerToDraft },
                    teamId: teamId,
                    slottedPosition: slottedPosition 
                });

                players = players.filter(p => p.Player !== playerToDraft.Player);

                // Push player with their slotted position to the team roster
                teamData.roster.push({ ...playerToDraft, slottedPos: slottedPosition });
                // Sort by slotted position, then by primary position for consistent display
                teamData.roster.sort((a, b) => {
                    if (a.slottedPos.localeCompare(b.slottedPos) !== 0) {
                        return a.slottedPos.localeCompare(b.slottedPos);
                    }
                    return a.Pos.localeCompare(b.Pos);
                });
                
                currentPick++;

                applyFiltersAndSort();
                renderRosters();
                updateDraftStatus();
                console.log('DEBUG: Player drafted successfully:', playerToDraft.Player); // Success log
                console.log('TRACE: draftPlayer END (Success)'); // TRACE END
            } catch (error) {
                console.error("An unexpected error occurred during draftPlayer:", error);
                showMessage('Unexpected Error', `An unexpected error occurred while drafting ${playerToDraft.Player}: ${error.message}. Check console for details.`);
                console.log('TRACE: draftPlayer END (Unexpected Error)'); // TRACE END
            }
        }

        /**
         * Undoes the last draft pick.
         */
        function undoLastPick() {
            if (draftHistory.length === 0) {
                showMessage('No Picks', 'No picks to undo.');
                return;
            }
            const lastPick = draftHistory.pop();
            const playerToUndo = lastPick.player;
            const teamId = lastPick.teamId;
            const slottedPosition = lastPick.slottedPosition; 
            const teamData = teamsById[teamId];
            
            players.push(playerToUndo);
            // Remove the player from the roster, ensuring we remove the specific instance if multiple identical players were drafted (e.g., in a mock scenario, though unlikely in a real draft)
            const playerIndexInRoster = teamData.roster.findIndex(p => p.Player === playerToUndo.Player && p.slottedPos === slottedPosition);
            if (playerIndexInRoster > -1) {
                teamData.roster.splice(playerIndexInRoster, 1);
            }
            
            // Decrement the count for the slot the player was actually in, but only if it's not 'Bench'
            // Ensure position exists in rosterSettings before decrementing
            if (slottedPosition !== 'Bench' && teamData.positions[slottedPosition] !== undefined && teamData.positions[slottedPosition] > 0) {
                teamData.positions[slottedPosition]--;
            }

            currentPick = lastPick.pickIndex;

            applyFiltersAndSort();
            renderRosters();
            updateDraftStatus();
        }

        /**
         * Calculates projected standings for all teams based on total projected points.
         * @returns {Array<Object>} Sorted list of teams with their total projected points.
         */
        function calculateProjectedStandings() {
            const standings = [];
            const weeksToConsider = 13; // Usually fantasy regular season is 13-14 weeks

            for (const teamId in teamsById) {
                const team = teamsById[teamId];
                let totalSeasonProjectedPoints = 0;
                for (let week = 1; week <= weeksToConsider; week++) {
                    const weekKey = `Week ${week}`;
                    // Ensure that the roster points calculation is consistent
                    const { totalPoints } = calculateRosterSpotsPoints(team.roster, weekKey);
                    totalSeasonProjectedPoints += totalPoints;
                }
                standings.push({
                    teamName: team.name,
                    totalProjectedPoints: totalSeasonProjectedPoints
                });
            }

            // Sort by total projected points (descending)
            standings.sort((a, b) => b.totalProjectedPoints - a.totalProjectedPoints);
            return standings;
        }

        /**
         * Renders the projected standings summary page.
         */
        function renderSummaryPage() {
            const standings = calculateProjectedStandings();
            standingsList.innerHTML = ''; // Clear previous standings

            if (standings.length === 0) {
                standingsList.innerHTML = '<p class="text-gray-500 text-center">No teams to display standings for.</p>';
            } else {
                standings.forEach((team, index) => {
                    const rank = index + 1;
                    const rankClass = rank <= 3 ? 'font-bold text-indigo-700' : 'text-gray-700';
                    standingsList.innerHTML += `
                        <div class="flex justify-between items-center p-3 border rounded-lg bg-gray-50">
                            <span class="text-lg ${rankClass}">${rank}. ${team.teamName}</span>
                            <span class="text-lg font-semibold text-blue-600">${team.totalProjectedPoints.toFixed(2)} pts</span>
                        </div>
                    `;
                });
            }

            // Hide drafting screen and show summary screen
            draftingScreen.classList.add('hidden');
            summaryScreen.classList.remove('hidden');
        }

        /**
         * Closes the summary page and returns to the drafting screen.
         */
        function closeSummaryPage() {
            summaryScreen.classList.add('hidden');
            draftingScreen.classList.remove('hidden');
        }


        /**
         * Saves the current draft state to local storage.
         */
        function saveDraft() {
            const draftState = {
                players,
                teamsById, // Save the entire teamsById object
                draftOrder,
                currentPick,
                draftStarted,
                draftHistory
            };
            localStorage.setItem('fantasyDraftState', JSON.stringify(draftState));
            showMessage('Draft Saved', 'Draft saved successfully!');
        }

        /**
         * Loads a saved draft state from local storage.
         */
        function loadDraft() {
            const savedState = localStorage.getItem('fantasyDraftState');
            if (savedState) {
                const draftState = JSON.parse(savedState);
                players = draftState.players;
                teamsById = draftState.teamsById; // Load teamsById
                draftOrder = draftState.draftOrder;
                currentPick = draftState.currentPick;
                draftStarted = draftState.draftStarted;
                draftHistory = draftState.draftHistory;

                // Ensure initialPositions are correctly set for loaded teams
                for (const teamId in teamsById) {
                    const team = teamsById[teamId];
                    const initialPositions = {};
                    Object.keys(rosterSettings).forEach(pos => {
                        if (pos !== 'totalStarters' && pos !== 'bench' && pos !== 'totalSize') {
                            initialPositions[pos] = 0;
                        }
                    });
                    team.positions = initialPositions; // Reset to 0
                    // Recalculate based on roster if needed, or assume saved state is correct
                    team.roster.forEach(player => {
                        if (player.slottedPos && team.positions[player.slottedPos] !== undefined) {
                            team.positions[player.slottedPos]++;
                        } else if (player.Pos && team.positions[player.Pos] !== undefined) { // Fallback to actual pos if slottedPos not found
                            team.positions[player.Pos]++;
                        }
                    });
                }


                showDraftingScreen();
                updateDraftStatus();
                renderRosters();
                applyFiltersAndSort();
                showMessage('Draft Loaded', 'Draft loaded successfully!');
            } else {
                showMessage('No Saved Draft', 'No saved draft found.');
            }
        }

        // Initial setup when the window loads
        window.addEventListener('load', () => {
            // Assign DOM elements to variables after they are loaded
            setupScreen = document.getElementById('setup-screen');
            draftingScreen = document.getElementById('drafting-screen');
            fileInput = document.getElementById('data-file');
            playersBody = document.getElementById('players-body');
            saveButton = document.getElementById('save-draft');
            loadDraftButton = document.getElementById('load-draft-button');
            undoButton = document.getElementById('undo-pick-button');
            upcomingPicksList = document.getElementById('upcoming-picks');
            playerSearchInput = document.getElementById('player-search');
            positionFilterSelect = document.getElementById('position-filter');
            sortBySelect = document.getElementById('sort-by');
            noAvailablePlayersMessage = document.getElementById('no-available-players');
            top5Container = document.getElementById('top-5-container');
            recommendationsContainer = document.getElementById('recommendations-container'); // Get reference to the container
            rosterTabsContainer = document.getElementById('roster-tabs');
            rosterContentContainer = document.getElementById('roster-content');
            currentRoundSpan = document.getElementById('current-round'); 
            currentPickNumberSpan = document.getElementById('current-pick-number');
            onTheClockSpan = document.getElementById('on-the-clock');
            loadDataButton = document.getElementById('load-data-button');
            urlInput = document.getElementById('url-input');
            loadUrlButton = document.getElementById('load-url-button');

            // New summary screen elements
            summaryScreen = document.getElementById('summary-screen');
            standingsList = document.getElementById('standings-list');
            viewStandingsButton = document.getElementById('view-standings-button');
            closeSummaryButton = document.getElementById('close-summary-button');

            // Assign message modal elements
            messageModal = document.getElementById('message-modal');
            messageModalTitle = document.getElementById('message-modal-title');
            messageModalContent = document.getElementById('message-modal-content');
            messageModalCloseButton = document.getElementById('message-modal-close');
            messageModalCloseButton.addEventListener('click', () => messageModal.classList.add('hidden'));
            
            console.log("DOM elements retrieved.");

            // Attach all event listeners
            fileInput.addEventListener('change', handleFileUpload);
            saveButton.addEventListener('click', saveDraft);
            loadDraftButton.addEventListener('click', loadDraft);
            undoButton.addEventListener('click', undoLastPick);
            loadDataButton.addEventListener('click', () => loadPlayersFromUrl(tsvFileUrl));
            loadUrlButton.addEventListener('click', () => loadPlayersFromUrl(urlInput.value));
            urlInput.addEventListener('input', () => {
                loadUrlButton.disabled = urlInput.value.trim() === '';
                if (loadUrlButton.disabled) {
                    loadUrlButton.classList.add('disabled-button');
                } else {
                    loadUrlButton.classList.remove('disabled-button');
                }
            });
            playerSearchInput.addEventListener('input', applyFiltersAndSort);
            positionFilterSelect.addEventListener('change', applyFiltersAndSort);
            sortBySelect.addEventListener('change', applyFiltersAndSort);
            viewStandingsButton.addEventListener('click', renderSummaryPage); 
            closeSummaryButton.addEventListener('click', closeSummaryPage); 

            // Event delegation for recommendation buttons
            recommendationsContainer.addEventListener('click', (e) => {
                const clickedButton = e.target.closest('.draft-button');
                if (clickedButton) {
                    e.stopPropagation(); // Stop propagation from the button itself
                    const playerId = clickedButton.getAttribute('data-player-id');
                    const playerToDraft = players.find(p => p.Player === playerId);
                    if (playerToDraft) {
                        console.log('DEBUG (Delegated): Select button clicked for player:', playerToDraft.Player);
                        draftPlayer(playerToDraft);
                    } else {
                        console.warn('Player not found for ID:', playerId);
                    }
                }
            });

            // Check for saved state and update UI accordingly
            const savedState = localStorage.getItem('fantasyDraftState');
            if (savedState) {
                loadDraftButton.classList.remove('hidden');
            } else {
                loadDraftButton.classList.add('hidden');
            }
            
            // Initial render of available players
            applyFiltersAndSort(); 
        });
    </script>
</body>
</html>
