<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Football Draft Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .table-container {
            max-height: 500px;
            overflow-y: auto;
        }
        .roster-content {
            max-height: 400px;
            overflow-y: auto;
        }
        /* Custom scrollbar for better aesthetics */
        .table-container::-webkit-scrollbar, .roster-content::-webkit-scrollbar {
            width: 8px;
            background-color: #f1f1f1;
            border-radius: 4px;
        }
        .table-container::-webkit-scrollbar-thumb, .roster-content::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        .table-container::-webkit-scrollbar-thumb:hover, .roster-content::-webkit-scrollbar-thumb:hover {
            background-color: #94a3b8;
        }
        /* Individual tab styling */
        .tab {
            @apply px-4 py-2 text-sm font-medium text-gray-600 border border-gray-200 rounded-t-lg transition duration-200 cursor-pointer -mb-px; /* Added full border, rounded top, and negative margin to overlap */
        }
        .tab.active {
            @apply text-indigo-600 border-indigo-600 font-semibold bg-white; /* Active tab stands out */
        }
        .tab:not(.active) {
            @apply bg-gray-50 hover:bg-gray-100; /* Inactive tabs look clickable */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Fantasy Football Draft Assistant</h1>
            <p class="text-lg text-gray-600 mt-2">12-Team Snake Draft Edition</p>
        </header>

        <!-- Setup Screen -->
        <div id="setup-screen" class="bg-white p-6 rounded-lg shadow-md max-w-lg mx-auto">
            <h2 class="text-2xl font-semibold mb-4 text-center">Setup Draft</h2>
            <div class="space-y-4">
                <div>
                    <label for="data-file" class="block text-sm font-medium text-gray-700 mb-1">1a. Upload Player TSV File</label>
                    <input type="file" id="data-file" accept=".tsv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100">
                </div>
                
                <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-gray-300">
                    <span class="text-xs text-gray-500 font-semibold">OR</span>
                    <hr class="flex-grow border-gray-300">
                </div>

                <div class="space-y-2">
                    <label for="url-input" class="block text-sm font-medium text-gray-700 mb-1">1b. Paste Player TSV URL</label>
                    <div class="flex space-x-2">
                        <input type="url" id="url-input" placeholder="e.g., https://example.com/data.tsv" class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <button id="load-url-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled-button" disabled>Load</button>
                    </div>
                </div>
                
                <div class="flex items-center space-x-2">
                    <hr class="flex-grow border-gray-300">
                    <span class="text-xs text-gray-500 font-semibold">OR</span>
                    <hr class="flex-grow border-gray-300">
                </div>
                
                <button id="load-data-button" class="w-full bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">1c. Load Player Data from GitHub</button>
                
                <div class="flex space-x-2">
                    <button id="load-draft-button" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 hidden">Load Existing Draft</button>
                </div>
            </div>
        </div>

        <!-- Drafting Screen -->
        <div id="drafting-screen" class="hidden">
            
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8"> 
                <!-- Left Column: Draft Status, Recommendations, Top 5 (stacked), then Draft Controls at bottom -->
                <div class="md:col-span-1 flex flex-col gap-6"> <!-- Using flex-col with gap for vertical spacing -->
                    
                    <div id="draft-status" class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="font-semibold text-lg mb-2">Draft Status</h3>
                        <div class="space-y-1 text-sm">
                            <p><strong>Round:</strong> <span id="current-round">N/A</span></p>
                            <p><strong>Pick:</strong> <span id="current-pick-number">N/A</span></p>
                            <p class="text-lg font-bold text-indigo-600"><strong>On the Clock:</strong> <span id="on-the-clock">N/A</span></p>
                        </div>
                        <div class="mt-4">
                            <h4 class="font-semibold text-md mb-2">Upcoming Picks:</h4>
                            <ul id="upcoming-picks" class="text-sm list-disc list-inside space-y-0.5"></ul>
                        </div>
                    </div>

                    <!-- Recommended Picks moved here -->
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-4 border-b pb-2">Recommended Picks</h3>
                        <div id="recommendations-container" class="space-y-4">
                            <p class="text-gray-500">Recommendations will appear here after the draft starts.</p>
                        </div>
                    </div>

                    <!-- Top 5 Available moved here -->
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-2xl font-semibold mb-4 border-b pb-2">Top 5 Available</h3>
                        <div id="top-5-container" class="space-y-4"></div>
                    </div>

                    <!-- Draft Controls moved to the very bottom of the left column -->
                    <div class="bg-white p-6 rounded-lg shadow-md mt-auto"> <!-- mt-auto pushes it to the bottom -->
                        <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Draft Controls</h2>
                        <div class="space-y-4">
                            <button id="save-draft" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save Draft</button>
                            <button id="undo-pick-button" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mt-2">Undo Last Pick</button>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Available Players, Team Rosters (now col-span-3) -->
                <div class="md:col-span-3 space-y-8"> 
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h2 class="text-2xl font-semibold mb-4">Available Players</h2>
                        <div class="space-y-4">
                            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                                <input type="text" id="player-search" placeholder="Search Player..." class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <select id="position-filter" class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white">
                                    <option value="">All Positions</option>
                                    <option value="QB">QB</option>
                                    <option value="RB">RB</option>
                                    <option value="WR">WR</option>
                                    <option value="TE">TE</option>
                                    <option value="PK">PK</option>
                                    <option value="Def">Def</option>
                                </select>
                                <select id="sort-by" class="px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm bg-white">
                                    <option value="VBD" selected>VBD (Highest First)</option>
                                    <option value="2025 Projected Fantasy Points">Proj. Points (Highest First)</option>
                                    <option value="Player">Player Name (A-Z)</option>
                                    <option value="Pos">Position (A-Z)</option>
                                    <option value="Team">Team (A-Z)</option>
                                </select>
                            </div>
                        </div>
                        <div class="table-container border rounded-lg mt-4">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50 sticky top-0">
                                    <tr>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Player</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Pos</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Team</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Bye</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Proj. Pts</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">VBD</th>
                                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="players-body" class="bg-white divide-y divide-gray-200"></tbody>
                            </table>
                            <p id="no-available-players" class="text-center text-gray-500 p-4 hidden">No players available based on current filters.</p>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h2 class="text-2xl font-semibold mb-4">Team Rosters</h2>
                        <!-- Parent container for tabs with flex, no direct borders for individual tab styling -->
                        <div id="roster-tabs" class="flex flex-wrap gap-x-1"></div> 
                        <!-- Content container will have borders -->
                        <div id="roster-content" class="roster-content mt-4 border border-gray-200 rounded-lg"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // --- STATE MANAGEMENT ---
        let players = [];
        let teamsById = {};
        let draftOrder = [];
        let currentPick = 0;
        let draftStarted = false;
        let draftHistory = [];

        // --- ROSTER SETTINGS ---
        // Updated roster settings as per user's request: 1QB, 2RB, 2WR, 1TE, 2FLEX, 1K, 1DEF
        const rosterSettings = {
            QB: { min: 1, max: 1 }, 
            RB: { min: 2, max: 2 }, // Updated from 4 to 2 as per user's request
            WR: { min: 2, max: 2 }, // Updated from 4 to 2 as per user's request
            TE: { min: 1, max: 1 }, // Updated from 2 to 1 as per user's request
            Flex: { min: 2, max: 2 }, 
            PK: { min: 1, max: 1 }, 
            Def: { min: 1, max: 1 }, 
            totalStarters: 10, // 1 QB + 2 RB + 2 WR + 1 TE + 2 Flex + 1 PK + 1 Def = 10
            bench: 6, // 16 total size - 10 starters = 6
            totalSize: 16
        };

        // --- DOM ELEMENTS (Declared here, assigned in window.onload) ---
        let setupScreen;
        let draftingScreen;
        let fileInput;
        let playersBody;
        let saveButton;
        let loadDraftButton;
        let undoButton;
        let loadDataButton;
        let urlInput;
        let loadUrlButton;
        let upcomingPicksList;
        let playerSearchInput;
        let positionFilterSelect;
        let sortBySelect;
        let noAvailablePlayersMessage;
        let top5Container;
        let recommendationsContainer;
        let rosterTabsContainer;
        let rosterContentContainer;
        let currentRoundSpan; 
        let currentPickNumberSpan;
        let onTheClockSpan;

        // --- Hard-coded URL for your TSV file ---
        const tsvFileUrl = 'https://raw.githubusercontent.com/APmsj09/Fantasy_Football/main/Data.tsv';

        /**
         * Generates a UUID.
         * @returns {string} A unique ID.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Switches the view from the setup screen to the main drafting screen.
         */
        function showDraftingScreen() {
            setupScreen.classList.add('hidden');
            draftingScreen.classList.remove('hidden');
            console.log("Switched to drafting screen.");
        }

        /**
         * Initializes the draft with default teams or loaded team names.
         * @param {Array<string>} [initialTeamNames] - Optional array of team names to use.
         */
        function initializeDraftSetup(initialTeamNames = []) {
            console.log("initializeDraftSetup called.");
            teamsById = {};
            draftOrder = [];
            currentPick = 0;
            draftHistory = [];
            draftStarted = true;

            let teamsToCreate = initialTeamNames.length > 0 ? initialTeamNames : Array.from({ length: 12 }, (_, i) => `Team ${i + 1}`);
            
            // Create teams with unique IDs
            let teamIds = [];
            teamsToCreate.forEach(name => {
                const id = generateUUID();
                // Initialize positions with 0 count
                const initialPositions = {};
                Object.keys(rosterSettings).forEach(pos => {
                    if (pos !== 'totalStarters' && pos !== 'bench' && pos !== 'totalSize') {
                        initialPositions[pos] = 0;
                    }
                });
                teamsById[id] = { id: id, name: name, roster: [], positions: initialPositions };
                teamIds.push(id);
            });

            // Populate draft order with team IDs
            for (let i = 0; i < rosterSettings.totalSize; i++) {
                const roundOrder = [...teamIds];
                if ((i + 1) % 2 === 0) { // Snake draft logic
                    roundOrder.reverse();
                }
                draftOrder.push(...roundOrder);
            }

            console.log("Draft initialized. Teams:", teamsById);
            showDraftingScreen();
            updateDraftStatus();
            renderRosters();
            applyFiltersAndSort();
        }


        /**
         * Parses TSV text into an array of player objects, including weekly projections.
         * @param {string} text - The TSV content.
         * @returns {Array<Object>} Array of player objects.
         */
        function parseTSV(text) {
            const rows = text.split(/\r?\n/).filter(row => row.trim() !== '');
            if (rows.length < 2) {
                alert('Data file must have a header and at least one player row.');
                return [];
            }
            const rawHeaders = rows[0].split('\t');
            const headers = rawHeaders.map(h => h.trim());
            console.log("TSV Headers found:", headers);

            // Find index of crucial columns
            const playerIndex = headers.indexOf('Player');
            const teamIndex = headers.indexOf('Team'); // Original index for "Team" column
            const posIndex = headers.indexOf('Pos');   // Original index for "Pos" column
            const projectedPointsIndex = headers.indexOf('2025 Projected Fantasy Points');
            const vbdIndex = headers.indexOf('VBD');
            const byeWeekIndex = headers.indexOf('Bye Week');

            if (playerIndex === -1 || teamIndex === -1 || posIndex === -1) {
                alert('Required columns (Player, Team, Pos) not found in the TSV file.');
                return [];
            }

            const parsedPlayers = [];
            for (let i = 1; i < rows.length; i++) {
                const values = rows[i].split('\t').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn(`Skipping row ${i + 1} due to header/value mismatch. Headers: ${headers.length}, Values: ${values.length}. Row: ${rows[i]}`);
                    continue; 
                }
                
                let player = {};
                player.Player = values[playerIndex];
                
                // *** FIX: Flip Pos and Team assignment as per user's error report ***
                // The value at the 'Pos' column index is actually the Team name.
                // The value at the 'Team' column index is actually the Position.
                player.Team = values[posIndex]; // Assign value from 'Pos' header's column to player.Team
                player.Pos = values[teamIndex]; // Assign value from 'Team' header's column to player.Pos
                
                // Standardize 'K' to 'PK' and 'DEF' to 'Def'
                if (player.Pos === 'K') {
                    player.Pos = 'PK';
                } else if (player.Pos === 'DEF') {
                    player.Pos = 'Def';
                }

                player['2025 Projected Fantasy Points'] = parseFloat(values[projectedPointsIndex]) || 0;
                player.VBD = (vbdIndex !== -1) ? parseFloat(values[vbdIndex]) || 0 : player['2025 Projected Fantasy Points'];
                player['Bye Week'] = values[byeWeekIndex];

                // Extract Weekly Projections
                for (let week = 1; week <= 18; week++) { // Assuming up to Week 18 projections
                    const weekHeader = `Week ${week}`;
                    const weekIndex = headers.indexOf(weekHeader);
                    if (weekIndex !== -1) {
                        player[weekHeader] = parseFloat(values[weekIndex]) || 0;
                    } else {
                        player[weekHeader] = 0; // Default to 0 if week projection is missing
                    }
                }

                // DEBUG: Log final parsed player object to confirm Pos and Team are correct after the flip
                if (player.Player === "Ja'Marr Chase" || parsedPlayers.length < 5) { // Log first 5 players and Ja'Marr Chase
                    console.log(`  Processed Player (Row ${i + 1}): Player: ${player.Player}, Raw Pos Column Value: '${values[posIndex]}', Raw Team Column Value: '${values[teamIndex]}', Final player.Pos: '${player.Pos}', Final player.Team: '${player.Team}'`);
                }
                parsedPlayers.push(player);
            }
            return parsedPlayers;
        }

        /**
         * Fetches and loads player data from a given URL.
         * @param {string} url - The URL of the TSV file.
         */
        function loadPlayersFromUrl(url) {
            const isGitHub = url.includes('github.com');
            let buttonToUpdate = isGitHub ? loadDataButton : loadUrlButton;
            
            buttonToUpdate.textContent = "Loading...";
            buttonToUpdate.disabled = true;

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok. Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    players = parseTSV(text);
                    if (players.length > 0) {
                        alert('Player data loaded successfully!');
                        buttonToUpdate.textContent = "Data Loaded!";
                        buttonToUpdate.classList.add('bg-green-500', 'hover:bg-green-600');
                        console.log("Players loaded successfully. Number of players:", players.length);
                        initializeDraftSetup(); // Automatically start draft after data loads
                    } else {
                         throw new Error('No player data found in the file.');
                    }
                })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
                    alert(`Failed to load data from URL: ${error.message}`);
                    buttonToUpdate.textContent = "Failed to Load";
                    buttonToUpdate.classList.remove('bg-green-500', 'hover:bg-green-600');
                    buttonToUpdate.classList.add('bg-red-500', 'hover:bg-red-600');
                })
                .finally(() => {
                    buttonToUpdate.disabled = false;
                });
        }

        /**
         * Handles local data file upload and parsing.
         */
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                players = parseTSV(text);
                if (players.length > 0) {
                    alert('Player data uploaded successfully from your device!');
                    console.log("Players loaded successfully from file. Number of players:", players.length);
                    initializeDraftSetup(); // Automatically start draft after data loads
                } else {
                    alert('Failed to parse player data from the file. Please check the file format.');
                }
            };
            reader.readAsText(file);
        }
        
        /**
         * Updates the UI with the current draft status and upcoming picks.
         */
        function updateDraftStatus() {
            if (!draftStarted || currentPick >= draftOrder.length) {
                onTheClockSpan.textContent = "Draft Complete!";
                currentRoundSpan.textContent = (rosterSettings.totalSize).toString();
                currentPickNumberSpan.textContent = draftOrder.length.toString();
                upcomingPicksList.innerHTML = '<li class="text-gray-500">Draft has concluded.</li>';
                return;
            }

            const round = Math.floor(currentPick / 12) + 1;
            const pickInRound = (currentPick % 12) + 1;
            const overallPick = currentPick + 1;
            const currentTeamId = draftOrder[currentPick];
            const currentTeamName = teamsById[currentTeamId].name;

            currentRoundSpan.textContent = round;
            currentPickNumberSpan.textContent = `${overallPick} (${pickInRound})`;
            onTheClockSpan.textContent = currentTeamName;

            upcomingPicksList.innerHTML = '';
            const numberOfFuturePicks = 5;
            for (let i = 1; i <= numberOfFuturePicks; i++) {
                const futurePickIndex = currentPick + i;
                if (futurePickIndex < draftOrder.length) {
                    const futureRound = Math.floor(futurePickIndex / 12) + 1;
                    const futurePickInRound = (futurePickIndex % 12) + 1;
                    const futureTeamId = draftOrder[futurePickIndex];
                    const futureTeamName = teamsById[futureTeamId].name;
                    upcomingPicksList.innerHTML += `<li>Pick ${futurePickIndex + 1} (R${futureRound}, P${futurePickInRound}): ${futureTeamName}</li>`;
                } else {
                    break;
                }
            }
            if (upcomingPicksList.innerHTML === '') {
                upcomingPicksList.innerHTML = '<li class="text-gray-500">No more future picks.</li>';
            }

            if (draftStarted) {
                renderRecommendations();
            }
        }

        /**
         * Generates and displays a list of recommended players for the team on the clock.
         */
        function renderRecommendations() {
            recommendationsContainer.innerHTML = '';
            const currentTeamId = draftOrder[currentPick];
            if (!currentTeamId) { // Check if draft is complete
                recommendationsContainer.innerHTML = `<p class="text-gray-500">Draft is complete.</p>`;
                return;
            }
            const currentTeamName = teamsById[currentTeamId].name;
            const teamRoster = teamsById[currentTeamId].roster;
            const teamPositions = teamsById[currentTeamId].positions;
            let rawRecommendations = []; // Store recommendations before final filtering/deduplication

            // Define all positions that can be drafted or are part of the roster settings
            const allRosterPositions = Object.keys(rosterSettings).filter(p => !['totalStarters', 'bench', 'totalSize'].includes(p));

            // Helper to check if a player is already in the global 'players' array (i.e., available)
            const isPlayerAvailable = (player) => players.some(p => p.Player === player.Player);

            // Stage 1: Prioritize players to fill vacant roster spots based on minimum requirements and VBD
            let criticalNeedsExist = false;
            for (const pos of allRosterPositions) {
                const currentCount = teamPositions[pos] || 0;
                if (rosterSettings[pos] && currentCount < rosterSettings[pos].min) {
                    criticalNeedsExist = true;
                    let filteredByPosPlayers;
                    if (pos === 'Flex') {
                        filteredByPosPlayers = players.filter(p => ['RB', 'WR', 'TE'].includes(p.Pos));
                    } else {
                        filteredByPosPlayers = players.filter(p => p.Pos === pos);
                    }

                    const topPosPlayers = filteredByPosPlayers
                        .sort((a, b) => b.VBD - a.VBD)
                        .slice(0, 3); // Get top few suggestions

                    topPosPlayers.forEach(p => rawRecommendations.push({
                        player: p,
                        reason: `High VBD to fill starting ${pos} slot.`,
                        priority: 1
                    }));
                }
            }

            // Stage 2: Maximize weekly points by targeting players for upcoming bye weeks
            // Only proceed if critical starting needs are met OR roster is almost full
            if (!criticalNeedsExist || teamRoster.length >= rosterSettings.totalSize - 3) {
                const currentDraftRound = Math.floor(currentPick / 12) + 1;
                const weeksToConsider = [];
                for (let i = 0; i < 4; i++) {
                    const targetWeek = currentDraftRound + i;
                    if (targetWeek >= 1 && targetWeek <= 18) {
                        weeksToConsider.push(targetWeek);
                    }
                }

                for (const week of weeksToConsider) {
                    const relevantByePlayers = teamRoster.filter(p => p['Bye Week'] == week && ['RB', 'WR', 'TE'].includes(p.slottedPos || p.Pos));
                    if (relevantByePlayers.length > 0) {
                        const topByeWeekFillers = players // Filter directly from 'players'
                            .filter(p => ['RB', 'WR', 'TE'].includes(p.Pos) && p['Bye Week'] != week)
                            .sort((a, b) => {
                                const aProj = a[`Week ${week}`] || 0;
                                const bProj = b[`Week ${week}`] || 0;
                                return bProj - aProj;
                            })
                            .slice(0, 2);

                        topByeWeekFillers.forEach(p => rawRecommendations.push({
                            player: p,
                            reason: `High projected points for bye week filler (Week ${week}).`,
                            priority: 2
                        }));
                    }
                }
            }

            // Stage 3: General depth/best available if remaining recommendation slots need to be filled
            if (rawRecommendations.length < 5 && teamRoster.length < rosterSettings.totalSize) {
                const generalDepthPlayers = players // Filter directly from 'players'
                    .sort((a, b) => {
                        if (b.VBD !== a.VBD) return b.VBD - a.VBD;
                        const aProjWeek1 = a['Week 1'] || 0;
                        const bProjWeek1 = b['Week 1'] || 0;
                        return bProjWeek1 - aProjWeek1;
                    });

                for (const player of generalDepthPlayers) {
                    // Only add if not already in rawRecommendations and is available
                    if (!rawRecommendations.some(rec => rec.player.Player === player.Player)) {
                        rawRecommendations.push({
                            player: player,
                            reason: `Best available player (High VBD).`,
                            priority: 3
                        });
                    }
                    if (rawRecommendations.length >= 5) break;
                }
            }

            // Final Deduplicate and filter by availability.
            const uniqueRecommendationsMap = new Map();
            for (const rec of rawRecommendations) {
                if (isPlayerAvailable(rec.player)) { // Explicitly check if the player is still available
                    if (!uniqueRecommendationsMap.has(rec.player.Player) || rec.priority < uniqueRecommendationsMap.get(rec.player.Player).priority) {
                        uniqueRecommendationsMap.set(rec.player.Player, rec);
                    }
                }
            }
            let finalRecommendations = Array.from(uniqueRecommendationsMap.values());

            // Sort by priority, then by VBD descending
            finalRecommendations.sort((a, b) => {
                if (a.priority !== b.priority) {
                    return a.priority - b.priority;
                }
                return b.player.VBD - a.player.VBD;
            });

            const top5FinalRecommendations = finalRecommendations.slice(0, 5);

            if (top5FinalRecommendations.length > 0) {
                top5FinalRecommendations.forEach(rec => {
                    const player = rec.player;
                    const recCard = document.createElement('div');
                    recCard.className = 'p-3 bg-gray-50 rounded-lg border flex items-center justify-between hover:bg-gray-100 cursor-pointer';
                    recCard.innerHTML = `
                        <div>
                            <h4 class="font-bold text-md text-indigo-600">${player.Player}</h4>
                            <p class="text-sm text-gray-600">${player.Pos} - ${player.Team} | VBD: ${player.VBD.toFixed(2)}</p>
                            <p class="text-xs text-gray-500 mt-1">${rec.reason}</p>
                        </div>
                        <button class="bg-indigo-500 text-white text-xs px-3 py-1 rounded hover:bg-indigo-600 draft-button" data-player-id="${player.Player}">Draft</button>
                    `;
                    recCard.querySelector('.draft-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        draftPlayer(player);
                    });
                    recommendationsContainer.appendChild(recCard);
                });
            } else {
                recommendationsContainer.innerHTML = `<p class="text-gray-500">No specific recommendations at this time.</p>`;
            }
        }

        /**
         * Applies current filters and sort order to the available players
         * and then renders the main players table.
         */
        function applyFiltersAndSort() {
            let filteredPlayers = [...players];

            const searchTerm = playerSearchInput.value.toLowerCase();
            if (searchTerm) {
                filteredPlayers = filteredPlayers.filter(player =>
                    player.Player.toLowerCase().includes(searchTerm) ||
                    player.Team.toLowerCase().includes(searchTerm)
                );
            }

            const selectedPosition = positionFilterSelect.value;
            if (selectedPosition) {
                filteredPlayers = filteredPlayers.filter(player => player.Pos === selectedPosition);
            }

            const sortBy = sortBySelect.value;
            filteredPlayers.sort((a, b) => {
                if (sortBy === 'Player' || sortBy === 'Pos' || sortBy === 'Team' || sortBy === 'Bye Week') {
                    return a[sortBy].localeCompare(b[sortBy]);
                } else if (sortBy === '2025 Projected Fantasy Points' || sortBy === 'VBD') {
                    return b[sortBy] - a[sortBy];
                }
                return 0;
            });

            renderPlayers(filteredPlayers);
            renderTop5(); 
        }

        /**
         * Renders the list of available players based on the provided array.
         */
        function renderPlayers(playersToRender) {
            playersBody.innerHTML = '';
            if (playersToRender.length === 0) {
                noAvailablePlayersMessage.classList.remove('hidden');
            } else {
                noAvailablePlayersMessage.classList.add('hidden');
                playersToRender.forEach((player) => {
                    const tr = document.createElement('tr');
                    tr.className = 'hover:bg-gray-100 cursor-pointer';
                    tr.ondblclick = () => draftPlayer(player);
                    
                    tr.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${player.Player}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Pos}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Team}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['Bye Week']}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['2025 Projected Fantasy Points']}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.VBD !== undefined ? player.VBD.toFixed(2) : 'N/A'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                            <button class="text-indigo-600 hover:text-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-300 rounded-md px-2 py-1 draft-button">Draft</button>
                        </td>
                    `;
                    const draftButton = tr.querySelector('.draft-button');
                    draftButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        draftPlayer(player);
                    });

                    playersBody.appendChild(tr);
                });
            }
        }

        /**
         * Handles editing a team's name directly from the roster tab.
         * @param {HTMLInputElement} inputElement - The input field being edited.
         * @param {string} teamId - The unique ID of the team being edited.
         */
        function editTeamName(inputElement, teamId) {
            const newName = inputElement.value.trim();
            if (newName && newName !== teamsById[teamId].name) {
                // Check for duplicate names (optional, but good practice)
                const isDuplicate = Object.values(teamsById).some(team => team.id !== teamId && team.name === newName);
                if (isDuplicate) {
                    alert('Team name must be unique!');
                    inputElement.value = teamsById[teamId].name; // Revert to old name
                    return;
                }
                teamsById[teamId].name = newName;
                console.log(`Team ${teamId} name updated to: ${newName}`);
                renderRosters(); // Re-render tabs to show updated name
                updateDraftStatus(); // Update "On the Clock" if needed
            } else {
                inputElement.value = teamsById[teamId].name; // Revert if empty or no change
            }
        }

        /**
         * Renders the tabbed roster UI.
         */
        function renderRosters() {
            rosterTabsContainer.innerHTML = '';
            rosterContentContainer.innerHTML = '';
            
            // Sort teams by their current display names
            const sortedTeamIds = Object.values(teamsById)
                                        .sort((a, b) => a.name.localeCompare(b.name))
                                        .map(team => team.id);
            
            let activeTabId = sortedTeamIds[0];
            const savedActiveTab = localStorage.getItem('activeRosterTab');
            if (savedActiveTab && sortedTeamIds.includes(savedActiveTab)) {
                activeTabId = savedActiveTab;
            }

            sortedTeamIds.forEach(teamId => {
                const team = teamsById[teamId];
                const isActive = teamId === activeTabId;
                const tab = document.createElement('button');
                // Added gap-x-1 to the parent roster-tabs div, so removed -mb-px from here
                tab.className = `tab ${isActive ? 'active' : ''}`;
                tab.textContent = team.name; // Display team's current name
                tab.onclick = () => switchRosterTab(team.id);
                rosterTabsContainer.appendChild(tab);
            });

            renderRosterContent(activeTabId);
        }

        /**
         * Renders the content for a specific team roster tab.
         * @param {string} teamId - The ID of the team to display.
         */
        function renderRosterContent(teamId) {
            rosterContentContainer.innerHTML = '';
            const teamData = teamsById[teamId];
            if (!teamData) {
                rosterContentContainer.innerHTML = '<p class="text-sm text-gray-500">Roster not found.</p>';
                return;
            }
            localStorage.setItem('activeRosterTab', teamId);

            const allRosterPositions = Object.keys(rosterSettings).filter(p => !['totalStarters', 'bench', 'totalSize'].includes(p));
            const posColors = {
                'QB': 'bg-blue-100',
                'RB': 'bg-green-100',
                'WR': 'bg-yellow-100',
                'TE': 'bg-red-100',
                'Flex': 'bg-purple-100', 
                'PK': 'bg-gray-200',
                'Def': 'bg-indigo-100'
            };

            const posSummary = allRosterPositions
                .map(pos => `${pos}: ${teamData.positions[pos] || 0}`)
                .join(', ');

            const playersHtml = teamData.roster.map(p => `
                <li class="flex justify-between items-center text-sm border-b border-gray-200 last:border-b-0 py-1 px-2 ${posColors[p.slottedPos || p.Pos] || 'bg-gray-50'} rounded">
                    <span class="font-medium">${p.Player}</span>
                    <span class="text-gray-600">${p.Pos} - ${p.Team} (${p.slottedPos})</span>
                </li>
            `).join('');

            // Calculate weekly points by position and week for Weeks 1-13
            const weeklyPointsByPosAndWeek = {};
            allRosterPositions.forEach(pos => {
                weeklyPointsByPosAndWeek[pos] = {};
                for (let week = 1; week <= 13; week++) { // Iterate weeks 1-13
                    weeklyPointsByPosAndWeek[pos][`Week ${week}`] = 0;
                }
            });

            teamData.roster.forEach(player => {
                const effectivePos = player.slottedPos; // Use slottedPos which is explicitly tracked
                for (let week = 1; week <= 13; week++) {
                    const weekKey = `Week ${week}`;
                    const weekProj = player[weekKey] || 0;
                    
                    if (weeklyPointsByPosAndWeek[effectivePos] && !isNaN(weekProj)) {
                        weeklyPointsByPosAndWeek[effectivePos][weekKey] += weekProj;
                    }
                }
            });

            let weeklyChartHtml = `<div class="mt-4 p-3 bg-white rounded-lg border">
                <h4 class="font-semibold text-md mb-2">Weekly Projected Points (Weeks 1-13):</h4>`;

            allRosterPositions.forEach(pos => {
                if (teamData.positions[pos] > 0) { // Only show positions with players
                    weeklyChartHtml += `<p class="text-sm font-medium mt-2">${pos}:</p><ul class="flex flex-wrap text-xs text-gray-700">`;
                    for (let week = 1; week <= 13; week++) {
                        const weekKey = `Week ${week}`;
                        const points = weeklyPointsByPosAndWeek[pos][weekKey].toFixed(1);
                        // Only display if there are actual points for the week
                        if (parseFloat(points) > 0) { 
                             weeklyChartHtml += `<li class="mr-2 mb-1">W${week}: <span class="font-bold">${points}</span></li>`;
                        }
                    }
                    weeklyChartHtml += `</ul>`;
                }
            });
            weeklyChartHtml += `</div>`;


            rosterContentContainer.innerHTML = `
                <div class="bg-gray-50 p-4 rounded-lg border shadow-md">
                    <h3 class="font-semibold text-lg mb-2 flex justify-between items-center">
                        <input type="text" value="${teamData.name}" class="bg-transparent font-semibold text-lg border-b border-gray-300 focus:outline-none focus:border-indigo-500 rounded-sm px-1 py-0.5 hover:bg-gray-100 transition duration-150" onblur="editTeamName(this, '${teamId}')">
                        <span class="text-sm text-gray-500">
                            <span class="text-blue-600 font-bold">${teamData.roster.length}</span>/${rosterSettings.totalSize} players
                        </span>
                    </h3>
                    <div class="w-full bg-gray-200 rounded-full h-2 mb-4">
                        <div class="bg-blue-600 h-2 rounded-full" style="width: ${(teamData.roster.length / rosterSettings.totalSize) * 100}%;"></div>
                    </div>
                    <p class="text-xs text-gray-600 mb-2">${posSummary}</p>
                    <ul class="space-y-1">
                        ${playersHtml || '<li class="text-sm text-gray-500">Roster is empty.</li>'}
                    </ul>
                    ${weeklyChartHtml}
                </div>
            `;
        }
        
        /**
         * Switches the active roster tab.
         * @param {string} teamId - The ID of the team to switch to.
         */
        function switchRosterTab(teamId) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const newActiveTab = document.querySelector(`.tab[onclick="switchRosterTab('${teamId}')"]`);
            if (newActiveTab) {
                newActiveTab.classList.add('active');
            }
            renderRosterContent(teamId);
        }

        /**
         * Renders the top 5 available players for key positions.
         */
        function renderTop5() {
            top5Container.innerHTML = '';
            console.log("renderTop5 called. Current players array length:", players.length); 
            const positions = ['QB', 'RB', 'WR', 'TE']; 

            if (players.length === 0) {
                 top5Container.innerHTML = `<p class="text-gray-500 text-center">No players available.</p>`;
                 console.log("No players available to render in Top 5.");
                 return;
            }

            positions.forEach(pos => {
                const topPlayers = players.filter(p => p.Pos === pos)
                    .sort((a, b) => b.VBD - a.VBD)
                    .slice(0, 5);

                console.log(`Top players for ${pos}:`, topPlayers.map(p => `${p.Player} (VBD: ${p.VBD.toFixed(2)})`)); 

                const listItemsHtml = topPlayers.map(p => `
                    <li class="flex justify-between items-center text-sm">
                        <span class="font-medium">${p.Player}</span>
                        <span class="text-gray-600">${p.Team} - ${p.VBD.toFixed(2)} VBD</span>
                    </li>
                `).join('');

                const posSection = document.createElement('div');
                posSection.className = 'p-3 bg-gray-50 rounded-lg';
                posSection.innerHTML = `
                    <h4 class="font-bold text-md mb-2 text-indigo-600">${pos}</h4>
                    <ul class="space-y-1">
                        ${listItemsHtml || '<li class="text-sm text-gray-500">No players available.</li>'}
                    </ul>
                `;
                top5Container.appendChild(posSection);
            });
            console.log("renderTop5 finished.");
        }

        /**
         * Handles drafting a player, updating team rosters, and advancing the draft.
         */
        function draftPlayer(playerToDraft) {
            if (!draftStarted) {
                alert('Please load data to start the draft.');
                return;
            }
            if (currentPick >= draftOrder.length) {
                alert('The draft is complete! No more picks available.');
                return;
            }

            const teamId = draftOrder[currentPick];
            const teamData = teamsById[teamId];
            const position = playerToDraft.Pos; // This is the player's primary position
            let slottedPosition = position; // This will be the position the player is actually slotted into

            // Defensive check for invalid position
            if (!rosterSettings[position]) {
                console.error(`Invalid or unexpected position '${position}' found for player ${playerToDraft.Player}.`);
                alert(`Cannot draft player: Invalid position '${position}'. Please check player data.`);
                return;
            }

            // Check if there's space in the primary position
            const currentPrimaryPosCount = teamData.positions[position] || 0;
            if (currentPrimaryPosCount < rosterSettings[position].max) {
                teamData.positions[position]++; // Increment primary position count
            } else if (['RB', 'WR', 'TE'].includes(position)) {
                // If primary position is full and it's a Flex-eligible player, try to slot into Flex
                const currentFlexCount = teamData.positions['Flex'] || 0;
                if (rosterSettings.Flex && currentFlexCount < rosterSettings.Flex.max) {
                    teamData.positions['Flex']++; // Increment Flex count
                    slottedPosition = 'Flex'; // Mark as slotted into Flex
                    console.log(`${playerToDraft.Player} drafted into Flex for ${teamData.name}.`);
                } else {
                    alert(`${teamData.name} already has the maximum number of ${position}s allowed (${rosterSettings[position].max}) and no Flex spots available. Please draft a player from a different position or a different Flex-eligible position.`);
                    return;
                }
            } else {
                // If primary position is full and not Flex-eligible
                alert(`${teamData.name} already has the maximum number of ${position}s allowed (${rosterSettings[position].max}). Please draft a player from a different position.`);
                return;
            }
            
            if (teamData.roster.length >= rosterSettings.totalSize) {
                alert(`${teamData.name}'s roster is full (${rosterSettings.totalSize} players). They cannot draft any more players.`);
                // Decrement the count for the position that was just incremented
                if (slottedPosition === 'Flex') {
                    teamData.positions['Flex']--;
                } else {
                    teamData.positions[position]--;
                }
                return;
            }

            draftHistory.push({
                pickIndex: currentPick,
                player: { ...playerToDraft },
                teamId: teamId,
                slottedPosition: slottedPosition // Store where the player was actually slotted
            });

            players = players.filter(p => p.Player !== playerToDraft.Player);

            // Push player with their slotted position to the team roster
            teamData.roster.push({ ...playerToDraft, slottedPos: slottedPosition });
            teamData.roster.sort((a, b) => a.Pos.localeCompare(b.Pos)); // Keep roster sorted by primary position
            
            currentPick++;

            applyFiltersAndSort();
            renderRosters();
            updateDraftStatus();
        }

        /**
         * Undoes the last draft pick.
         */
        function undoLastPick() {
            if (draftHistory.length === 0) {
                alert('No picks to undo.');
                return;
            }
            const lastPick = draftHistory.pop();
            const playerToUndo = lastPick.player;
            const teamId = lastPick.teamId;
            const slottedPosition = lastPick.slottedPosition; // Get the actual slot
            const teamData = teamsById[teamId];
            
            players.push(playerToUndo);
            teamData.roster = teamData.roster.filter(p => p.Player !== playerToUndo.Player || (p.Player === playerToUndo.Player && p.slottedPos !== slottedPosition));
            
            // Decrement the count for the slot the player was actually in
            if (teamData.positions[slottedPosition] > 0) {
                teamData.positions[slottedPosition]--;
            }

            currentPick = lastPick.pickIndex;

            applyFiltersAndSort();
            renderRosters();
            updateDraftStatus();
        }

        /**
         * Saves the current draft state to local storage.
         */
        function saveDraft() {
            const draftState = {
                players,
                teamsById, // Save the entire teamsById object
                draftOrder,
                currentPick,
                draftStarted,
                draftHistory
            };
            localStorage.setItem('fantasyDraftState', JSON.stringify(draftState));
            alert('Draft saved successfully!');
        }

        /**
         * Loads a saved draft state from local storage.
         */
        function loadDraft() {
            const savedState = localStorage.getItem('fantasyDraftState');
            if (savedState) {
                const draftState = JSON.parse(savedState);
                players = draftState.players;
                teamsById = draftState.teamsById; // Load teamsById
                draftOrder = draftState.draftOrder;
                currentPick = draftState.currentPick;
                draftStarted = draftState.draftStarted;
                draftHistory = draftState.draftHistory;

                showDraftingScreen();
                updateDraftStatus();
                renderRosters();
                applyFiltersAndSort();
                alert('Draft loaded successfully!');
            } else {
                alert('No saved draft found.');
            }
        }

        // Initial setup when the window loads
        window.addEventListener('load', () => {
            // Assign DOM elements to variables after they are loaded
            setupScreen = document.getElementById('setup-screen');
            draftingScreen = document.getElementById('drafting-screen');
            fileInput = document.getElementById('data-file');
            playersBody = document.getElementById('players-body');
            saveButton = document.getElementById('save-draft');
            loadDraftButton = document.getElementById('load-draft-button');
            undoButton = document.getElementById('undo-pick-button');
            upcomingPicksList = document.getElementById('upcoming-picks');
            playerSearchInput = document.getElementById('player-search');
            positionFilterSelect = document.getElementById('position-filter');
            sortBySelect = document.getElementById('sort-by');
            noAvailablePlayersMessage = document.getElementById('no-available-players');
            top5Container = document.getElementById('top-5-container');
            recommendationsContainer = document.getElementById('recommendations-container');
            rosterTabsContainer = document.getElementById('roster-tabs');
            rosterContentContainer = document.getElementById('roster-content');
            currentRoundSpan = document.getElementById('current-round'); 
            currentPickNumberSpan = document.getElementById('current-pick-number');
            onTheClockSpan = document.getElementById('on-the-clock');
            loadDataButton = document.getElementById('load-data-button');
            urlInput = document.getElementById('url-input');
            loadUrlButton = document.getElementById('load-url-button');
            
            console.log("DOM elements retrieved.");

            // Attach all event listeners
            fileInput.addEventListener('change', handleFileUpload);
            saveButton.addEventListener('click', saveDraft);
            loadDraftButton.addEventListener('click', loadDraft);
            undoButton.addEventListener('click', undoLastPick);
            loadDataButton.addEventListener('click', () => loadPlayersFromUrl(tsvFileUrl));
            loadUrlButton.addEventListener('click', () => loadPlayersFromUrl(urlInput.value));
            urlInput.addEventListener('input', () => {
                loadUrlButton.disabled = urlInput.value.trim() === '';
                if (loadUrlButton.disabled) {
                    loadUrlButton.classList.add('disabled-button');
                } else {
                    loadUrlButton.classList.remove('disabled-button');
                }
            });
            playerSearchInput.addEventListener('input', applyFiltersAndSort);
            positionFilterSelect.addEventListener('change', applyFiltersAndSort);
            sortBySelect.addEventListener('change', applyFiltersAndSort);

            // Check for saved state and update UI accordingly
            const savedState = localStorage.getItem('fantasyDraftState');
            if (savedState) {
                loadDraftButton.classList.remove('hidden');
            } else {
                loadDraftButton.classList.add('hidden');
            }
            
            // Initial render of available players
            applyFiltersAndSort(); 
        });
    </script>
</body>
</html>
