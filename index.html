// --- STATE MANAGEMENT ---
let players = []; // This array will hold all available player data.
let teams = {}; // { "Team Name": { roster: [player1], positions: {QB:1, RB:2...} } }
let draftOrder = [];
let currentPick = 0;
let draftStarted = false;
let draftHistory = [];

// --- ROSTER SETTINGS ---
const rosterSettings = {
    QB: { min: 0, max: 1 },
    RB: { min: 2, max: 4 },
    WR: { min: 2, max: 4 },
    TE: { min: 1, max: 3 },
    PK: { min: 0, max: 1 },
    Def: { min: 0, max: 1 },
    totalStarters: 10,
    bench: 6,
    totalSize: 16
};

// --- DOM ELEMENTS ---
const fileInput = document.getElementById('data-file');
const playersBody = document.getElementById('players-body');
const rostersContainer = document.getElementById('rosters-container');
const saveButton = document.getElementById('save-draft');
const loadButton = document.getElementById('load-draft');
const undoButton = document.getElementById('undo-pick-button');
const setupDraftButton = document.getElementById('setup-draft-button');
const modal = document.getElementById('team-name-modal');
const teamNameInputsContainer = document.getElementById('team-name-inputs');
const startDraftButton = document.getElementById('start-draft-button');
const draftStatusDiv = document.getElementById('draft-status');
const currentRoundSpan = document.getElementById('current-round');
const currentPickNumberSpan = document.getElementById('current-pick-number');
const onTheClockSpan = document.getElementById('on-the-clock');
const loadDataButton = document.getElementById('load-data-button');
const upcomingPicksList = document.getElementById('upcoming-picks');
const playerSearchInput = document.getElementById('player-search');
const positionFilterSelect = document.getElementById('position-filter');
const sortBySelect = document.getElementById('sort-by');
const noAvailablePlayersMessage = document.getElementById('no-available-players');
const top5Container = document.getElementById('top-5-container');
const recommendationsContainer = document.getElementById('recommendations-container');

// --- Hard-coded URL for your TSV file ---
const tsvFileUrl = 'https://github.com/APmsj09/Fantasy_Football/blob/main/Data.tsv';

// --- EVENT LISTENERS ---
fileInput.addEventListener('change', handleFileUpload);
saveButton.addEventListener('click', saveDraft);
loadButton.addEventListener('click', loadDraft);
undoButton.addEventListener('click', undoLastPick);
setupDraftButton.addEventListener('click', showTeamNameModal);
startDraftButton.addEventListener('click', startDraft);
loadDataButton.addEventListener('click', loadPlayersFromGitHub);
playerSearchInput.addEventListener('input', applyFiltersAndSort);
positionFilterSelect.addEventListener('change', applyFiltersAndSort);
sortBySelect.addEventListener('change', applyFiltersAndSort);

/**
 * Handles local data file upload and parsing.
 */
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const text = e.target.result;
        players = parseTSV(text);
        applyFiltersAndSort();
        alert('Player data uploaded successfully from your device!');
    };
    reader.readAsText(file);
}

/**
 * Fetches and loads player data from the hard-coded GitHub URL.
 */
function loadPlayersFromGitHub() {
    fetch(tsvFileUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok. Please ensure the file URL is correct and you are logged into GitHub to access private repositories.');
            }
            return response.text();
        })
        .then(text => {
            players = parseTSV(text);
            applyFiltersAndSort();
            alert('Player data loaded successfully from GitHub!');
        })
        .catch(error => {
            console.error('There has been a problem with your fetch operation:', error);
            alert('Failed to load data from GitHub. Please check your internet connection, the file URL, and ensure you are logged into GitHub.');
        });
}

/**
 * Parses TSV text into an array of player objects, including weekly projections.
 * @param {string} text - The TSV content.
 * @returns {Array<Object>} Array of player objects.
 */
function parseTSV(text) {
    const rows = text.split(/\r?\n/).filter(row => row.trim() !== '');
    if (rows.length < 2) {
        alert('Data file must have a header and at least one player row.');
        return [];
    }
    const headers = rows[0].split('\t').map(h => h.trim());
    const parsedPlayers = [];
    for (let i = 1; i < rows.length; i++) {
        const values = rows[i].split('\t').map(v => v.trim());
        if (values.length === headers.length) {
            let player = {};
            headers.forEach((header, index) => {
                let value = values[index];
                if (header.startsWith('Week ') || header === '2025 Projected Fantasy Points' || header === 'VBD') {
                    player[header] = parseFloat(value) || 0;
                } else {
                    player[header] = value;
                }
            });
            parsedPlayers.push(player);
        }
    }
    if (!headers.includes('VBD')) {
        parsedPlayers.forEach(p => {
            p.VBD = p['2025 Projected Fantasy Points'] || 0;
        });
        console.warn("VBD column not found. Using '2025 Projected Fantasy Points' as VBD.");
    }
    return parsedPlayers;
}

/**
 * Shows the modal to enter team names.
 */
function showTeamNameModal() {
    if (players.length === 0) {
        alert('Please load player data first, either by uploading a file or by loading from GitHub.');
        return;
    }
    teamNameInputsContainer.innerHTML = '';
    for (let i = 1; i <= 12; i++) {
        teamNameInputsContainer.innerHTML += `
            <div>
                <label for="team-${i}" class="block text-sm font-medium text-gray-700">Team ${i}</label>
                <input type="text" id="team-${i}" value="Team ${i}" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
        `;
    }
    modal.classList.remove('hidden');
}

/**
 * Initializes and starts the draft.
 */
function startDraft() {
    const teamNames = [];
    for (let i = 1; i <= 12; i++) {
        const input = document.getElementById(`team-${i}`);
        if (!input.value.trim()) {
            alert(`Please enter a name for Team ${i}.`);
            return;
        }
        teamNames.push(input.value.trim());
    }

    teams = {};
    draftOrder = [];
    currentPick = 0;
    draftHistory = [];

    teamNames.forEach(name => {
        teams[name] = { roster: [], positions: {} };
    });

    for (let i = 0; i < rosterSettings.totalSize; i++) {
        const roundOrder = [...teamNames];
        if ((i + 1) % 2 === 0) {
            roundOrder.reverse();
        }
        draftOrder.push(...roundOrder);
    }

    draftStarted = true;
    modal.classList.add('hidden');
    draftStatusDiv.classList.remove('hidden');
    updateDraftStatus();
    renderRosters();
    applyFiltersAndSort();
}

/**
 * Updates the UI with the current draft status and upcoming picks.
 */
function updateDraftStatus() {
    if (!draftStarted || currentPick >= draftOrder.length) {
        onTheClockSpan.textContent = "Draft Complete!";
        currentRoundSpan.textContent = (rosterSettings.totalSize).toString();
        currentPickNumberSpan.textContent = draftOrder.length.toString();
        upcomingPicksList.innerHTML = '<li class="text-gray-500">Draft has concluded.</li>';
        return;
    }

    const round = Math.floor(currentPick / 12) + 1;
    const pickInRound = (currentPick % 12) + 1;
    const overallPick = currentPick + 1;
    const currentTeam = draftOrder[currentPick];

    currentRoundSpan.textContent = round;
    currentPickNumberSpan.textContent = `${overallPick} (${pickInRound})`;
    onTheClockSpan.textContent = currentTeam;

    upcomingPicksList.innerHTML = '';
    const numberOfFuturePicks = 5;
    for (let i = 1; i <= numberOfFuturePicks; i++) {
        const futurePickIndex = currentPick + i;
        if (futurePickIndex < draftOrder.length) {
            const futureRound = Math.floor(futurePickIndex / 12) + 1;
            const futurePickInRound = (futurePickIndex % 12) + 1;
            const futureTeam = draftOrder[futurePickIndex];
            upcomingPicksList.innerHTML += `<li>Pick ${futurePickIndex + 1} (R${futureRound}, P${futurePickInRound}): ${futureTeam}</li>`;
        } else {
            break;
        }
    }
    if (upcomingPicksList.innerHTML === '') {
        upcomingPicksList.innerHTML = '<li class="text-gray-500">No more future picks.</li>';
    }

    // Call the recommendation function after updating draft status
    if (draftStarted) {
        renderRecommendations();
    }
}

/**
 * Generates and displays a list of recommended players for the team on the clock.
 */
function renderRecommendations() {
    recommendationsContainer.innerHTML = '';
    const currentTeamName = draftOrder[currentPick];
    if (!currentTeamName) {
        recommendationsContainer.innerHTML = `<p class="text-gray-500">Draft is complete.</p>`;
        return;
    }

    const teamRoster = teams[currentTeamName].roster;

    // --- Recommendation Logic ---
    const recommendations = [];
    const positionsToDraft = ['RB', 'WR', 'QB', 'TE'];

    // Prioritize filling empty starting spots
    let startersNeeded = rosterSettings.totalStarters - teamRoster.length;
    if (startersNeeded > 0) {
        // Sort available players by VBD (or your preferred primary metric)
        const sortedAvailablePlayers = [...players].sort((a, b) => b.VBD - a.VBD);

        // Find the top players for each position that the team needs
        for (const pos of positionsToDraft) {
            const neededCount = rosterSettings[pos].max - (teams[currentTeamName].positions[pos] || 0);
            if (neededCount > 0) {
                const topPosPlayers = sortedAvailablePlayers.filter(p => p.Pos === pos).slice(0, 3);
                recommendations.push(...topPosPlayers.map(p => ({
                    player: p,
                    reason: `High VBD player at a position of need.`
                })));
            }
        }
    }

    // Prioritize players who can cover bye weeks
    const byeWeeks = teamRoster.map(p => p['Bye Week']);
    const availablePlayersWithBye = players.filter(p => !byeWeeks.includes(p['Bye Week']));
    availablePlayersWithBye.sort((a, b) => {
        const aTotalProj = Object.keys(a).filter(key => key.startsWith('Week ')).reduce((sum, key) => sum + a[key], 0);
        const bTotalProj = Object.keys(b).filter(key => key.startsWith('Week ')).reduce((sum, key) => sum + b[key], 0);
        return bTotalProj - aTotalProj;
    });

    const byeRecommendations = availablePlayersWithBye.slice(0, 3).map(p => ({
        player: p,
        reason: `Potential high-value bye week filler.`
    }));
    recommendations.push(...byeRecommendations);

    // Merge and show the top 5 unique recommendations
    const uniqueRecommendations = recommendations.filter((item, index, self) =>
        index === self.findIndex((t) => (
            t.player.Player === item.player.Player
        ))
    );

    const top5Recommendations = uniqueRecommendations.slice(0, 5);

    if (top5Recommendations.length > 0) {
        top5Recommendations.forEach(rec => {
            const player = rec.player;
            const recCard = document.createElement('div');
            recCard.className = 'p-3 bg-gray-50 rounded-lg border flex items-center justify-between hover:bg-gray-100 cursor-pointer';
            recCard.innerHTML = `
                <div>
                    <h4 class="font-bold text-md text-indigo-600">${player.Player}</h4>
                    <p class="text-sm text-gray-600">${player.Pos} - ${player.Team} | VBD: ${player.VBD.toFixed(2)}</p>
                    <p class="text-xs text-gray-500 mt-1">${rec.reason}</p>
                </div>
                <button class="bg-indigo-500 text-white text-xs px-3 py-1 rounded hover:bg-indigo-600 draft-button" data-player-id="${player.Player}">Draft</button>
            `;
            recCard.querySelector('.draft-button').addEventListener('click', (e) => {
                e.stopPropagation();
                draftPlayer(player);
            });
            recommendationsContainer.appendChild(recCard);
        });
    } else {
        recommendationsContainer.innerHTML = `<p class="text-gray-500">No specific recommendations at this time.</p>`;
    }
}


/**
 * Applies current filters and sort order to the available players
 * and then renders the main players table.
 */
function applyFiltersAndSort() {
    let filteredPlayers = [...players]; // Start with all available players

    const searchTerm = playerSearchInput.value.toLowerCase();
    if (searchTerm) {
        filteredPlayers = filteredPlayers.filter(player =>
            player.Player.toLowerCase().includes(searchTerm) ||
            player.Team.toLowerCase().includes(searchTerm)
        );
    }

    const selectedPosition = positionFilterSelect.value;
    if (selectedPosition) {
        filteredPlayers = filteredPlayers.filter(player => player.Pos === selectedPosition);
    }

    const sortBy = sortBySelect.value;
    filteredPlayers.sort((a, b) => {
        if (sortBy === 'Player' || sortBy === 'Pos' || sortBy === 'Team' || sortBy === 'Bye Week') {
            return a[sortBy].localeCompare(b[sortBy]);
        } else if (sortBy === '2025 Projected Fantasy Points' || sortBy === 'VBD') {
            return b[sortBy] - a[sortBy];
        }
        return 0;
    });

    renderPlayers(filteredPlayers);
    renderTop5();
}

/**
 * Renders the list of available players based on the provided array.
 */
function renderPlayers(playersToRender) {
    playersBody.innerHTML = '';
    if (playersToRender.length === 0) {
        noAvailablePlayersMessage.classList.remove('hidden');
    } else {
        noAvailablePlayersMessage.classList.add('hidden');
        playersToRender.forEach((player) => {
            const tr = document.createElement('tr');
            tr.className = 'hover:bg-gray-100 cursor-pointer';
            tr.ondblclick = () => draftPlayer(player);
            
            tr.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${player.Player}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Pos}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.Team}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['Bye Week']}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player['2025 Projected Fantasy Points']}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${player.VBD !== undefined ? player.VBD.toFixed(2) : 'N/A'}</td>
                <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                    <button class="text-indigo-600 hover:text-indigo-900 focus:outline-none focus:ring-2 focus:ring-indigo-300 rounded-md px-2 py-1 draft-button">Draft</button>
                </td>
            `;
            const draftButton = tr.querySelector('.draft-button');
            draftButton.addEventListener('click', (e) => {
                e.stopPropagation();
                draftPlayer(player);
            });

            playersBody.appendChild(tr);
        });
    }
}

/**
 * Renders the team rosters.
 */
function renderRosters() {
    rostersContainer.innerHTML = '';
    const positions = ['QB', 'RB', 'WR', 'TE', 'PK', 'Def'];
    const posColors = {
        'QB': 'bg-blue-100',
        'RB': 'bg-green-100',
        'WR': 'bg-yellow-100',
        'TE': 'bg-red-100',
        'PK': 'bg-purple-100',
        'Def': 'bg-indigo-100'
    };

    Object.keys(teams).sort().forEach(teamName => {
        const teamData = teams[teamName];
        const teamCard = document.createElement('div');
        teamCard.className = 'bg-gray-50 p-4 rounded-lg border roster-card shadow-sm';

        const rosterPercentage = (teamData.roster.length / rosterSettings.totalSize) * 100;
        const posSummary = positions
            .map(pos => `${pos}: ${teamData.positions[pos] || 0}`)
            .join(', ');

        const playersHtml = teamData.roster.map(p => `
            <li class="flex justify-between items-center text-sm border-b border-gray-200 last:border-b-0 py-1 px-2 ${posColors[p.Pos]} rounded">
                <span class="font-medium">${p.Player}</span>
                <span class="text-gray-600">${p.Pos} - ${p.Team}</span>
            </li>
        `).join('');

        teamCard.innerHTML = `
            <h3 class="font-semibold text-lg mb-2 flex justify-between items-center">
                <span>${teamName}</span>
                <span class="text-sm text-gray-500">
                    <span class="text-blue-600 font-bold">${teamData.roster.length}</span>/${rosterSettings.totalSize} players
                </span>
            </h3>
            <div class="w-full bg-gray-200 rounded-full h-2 mb-4">
                <div class="bg-blue-600 h-2 rounded-full" style="width: ${rosterPercentage}%;"></div>
            </div>
            <p class="text-xs text-gray-600 mb-2">${posSummary}</p>
            <ul class="space-y-1">
                ${playersHtml || '<li class="text-sm text-gray-500">Roster is empty.</li>'}
            </ul>
        `;
        rostersContainer.appendChild(teamCard);
    });
}

/**
 * Renders the top 5 available players for key positions.
 */
function renderTop5() {
    top5Container.innerHTML = '';
    const positions = ['QB', 'RB', 'WR', 'TE'];

    positions.forEach(pos => {
        const topPlayers = players.filter(p => p.Pos === pos)
            .sort((a, b) => b.VBD - a.VBD)
            .slice(0, 5);

        const listItemsHtml = topPlayers.map(p => `
            <li class="flex justify-between items-center text-sm">
                <span class="font-medium">${p.Player}</span>
                <span class="text-gray-600">${p.Team} - ${p.VBD.toFixed(2)} VBD</span>
            </li>
        `).join('');

        const posSection = document.createElement('div');
        posSection.className = 'p-3 bg-gray-50 rounded-lg';
        posSection.innerHTML = `
            <h4 class="font-bold text-md mb-2 text-indigo-600">${pos}</h4>
            <ul class="space-y-1">
                ${listItemsHtml || '<li class="text-sm text-gray-500">No players available.</li>'}
            </ul>
        `;
        top5Container.appendChild(posSection);
    });
}

/**
 * Handles drafting a player, updating team rosters, and advancing the draft.
 */
function draftPlayer(playerToDraft) {
    if (!draftStarted) {
        alert('Please set up and start the draft first.');
        return;
    }
    if (currentPick >= draftOrder.length) {
        alert('The draft is complete! No more picks available.');
        return;
    }

    const teamName = draftOrder[currentPick];
    const teamData = teams[teamName];
    const position = playerToDraft.Pos;

    const currentPositionCount = teamData.positions[position] || 0;
    if (rosterSettings[position] && currentPositionCount >= rosterSettings[position].max) {
        alert(`${teamName} already has the maximum number of ${position}s allowed (${rosterSettings[position].max}). Please draft a player from a different position.`);
        return;
    }
    if (teamData.roster.length >= rosterSettings.totalSize) {
        alert(`${teamName}'s roster is full (${rosterSettings.totalSize} players). They cannot draft any more players.`);
        return;
    }

    // Record the pick in history before modifying state
    draftHistory.push({
        pickIndex: currentPick,
        player: { ...playerToDraft },
        teamName: teamName
    });

    // Remove player from the main player list
    players = players.filter(p => p.Player !== playerToDraft.Player);

    // Add player to the team's roster
    teamData.roster.push(playerToDraft);
    teamData.roster.sort((a, b) => a.Pos.localeCompare(b.Pos)); // Keep roster sorted by position
    teamData.positions[position] = (teamData.positions[position] || 0) + 1;

    // Advance the draft
    currentPick++;

    // Update the UI
    applyFiltersAndSort();
    renderRosters();
    updateDraftStatus();
}

/**
 * Undoes the last draft pick.
 */
function undoLastPick() {
    if (draftHistory.length === 0) {
        alert('No picks to undo.');
        return;
    }
    const lastPick = draftHistory.pop();
    const playerToUndo = lastPick.player;
    const teamName = lastPick.teamName;
    const teamData = teams[teamName];
    const position = playerToUndo.Pos;

    // Add the player back to the available players list
    players.push(playerToUndo);

    // Remove the player from the team's roster
    teamData.roster = teamData.roster.filter(p => p.Player !== playerToUndo.Player);
    teamData.positions[position] = (teamData.positions[position] || 1) - 1;

    // Go back one pick in the draft order
    currentPick = lastPick.pickIndex;

    // Update the UI
    applyFiltersAndSort();
    renderRosters();
    updateDraftStatus();
}

/**
 * Saves the current draft state to local storage.
 */
function saveDraft() {
    const draftState = {
        players,
        teams,
        draftOrder,
        currentPick,
        draftStarted,
        draftHistory
    };
    localStorage.setItem('fantasyDraftState', JSON.stringify(draftState));
    alert('Draft saved successfully!');
}

/**
 * Loads a saved draft state from local storage.
 */
function loadDraft() {
    const savedState = localStorage.getItem('fantasyDraftState');
    if (savedState) {
        const draftState = JSON.parse(savedState);
        players = draftState.players;
        teams = draftState.teams;
        draftOrder = draftState.draftOrder;
        currentPick = draftState.currentPick;
        draftStarted = draftState.draftStarted;
        draftHistory = draftState.draftHistory;

        // Re-render UI based on loaded state
        draftStatusDiv.classList.remove('hidden');
        updateDraftStatus();
        renderRosters();
        applyFiltersAndSort();
        alert('Draft loaded successfully!');
    } else {
        alert('No saved draft found.');
    }
}

// Initial render
applyFiltersAndSort();
renderRosters();
